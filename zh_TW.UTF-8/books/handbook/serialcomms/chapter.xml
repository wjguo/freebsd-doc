<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <title>串列通訊</title>

  <sect1 xml:id="serial-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>serial communications</primary></indexterm>
    <para>
	從最早期以串列線作為使用者輸入輸出的 &unix; 機器開始，&unix; 一直都支援串列通訊，當時一般的終端機，如每秒 10 個字元的印表機和鍵盤，到現在已經改變很多。本章涵蓋一些可以用在 &os; 的串列通訊的方法。</para>

    <para>讀完本章，你將知道</para>

    <itemizedlist>
      <listitem>
	<para>如何透過終端機連線到 &os; 系統。</para>
      </listitem>
      <listitem>
	<para>如何利用 modem 撥號到遠端主機。</para>
      </listitem>
      <listitem>
	<para>如何允許遠端的使用者透過 modem 登入 &os; 系統</para>
      </listitem>
      <listitem>
	<para>如何從 serial console 將 &os; 開機。</para>
      </listitem>
    </itemizedlist>

    <para>在讀本章之前，你應該:</para>

    <itemizedlist>
      <listitem>
	<para>知道如何 <link linkend="kernelconfig"> 設定和安裝一個客制化的核心</link>。</para>
      </listitem>
      <listitem>
	<para>瞭解<link linkend="basics"> &os; 權限和程序</link>.</para>
      </listitem>
      <listitem>
	<para>Have access to the technical manual for the serial
	  hardware to be used with &os;.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>串列術語與硬體</title>

    <para>下列是常用的串列通訊專有名詞:</para>
    <variablelist>
      <varlistentry>
	<term><acronym>bps</acronym></term>
	<listitem>
	  <para>Bits per
	    Second<indexterm><primary>bits-per-second</primary></indexterm>
	    (<acronym>bps</acronym>) 是每秒資料傳輸速率</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>DTE</acronym></term>
	<listitem>
	  <para>Data Terminal
	    Equipment<indexterm><primary>DTE</primary></indexterm>
	    (<acronym>DTE</acronym>) 是串列通訊中的兩端點之一，例如電腦。
	    </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>DCE</acronym></term>
	<listitem>
	  <para>Data Communications
	    Equipment<indexterm><primary>DCE</primary></indexterm>
	    (<acronym>DTE</acronym>) 是串列通訊的另一個端點，基本上，它可能是一個 modem 或串列終端。
	    </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>RS-232</acronym></term>
	<listitem>
	  <para>原本定義硬體串列通訊的標準，它已經被重新命名為
	    <acronym>TIA-232</acronym>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>當提及通訊資料速率，本節將不使用<firstterm>鮑</firstterm>。鮑是指一段時間電子狀態轉換的次數；實際上，而 <acronym>bps</acronym> 才是通訊資料速率的正確用詞。</para>

    <para>為了透過串列終端機連到 &os; 系統，電腦必須要有一個串列阜和適當的串列線，對於串列硬體和接線方式很熟的讀者，可以放心地略過本節。</para>

    <sect2 xml:id="term-cables-null">
      <title>串列纜線和串列阜</title>

      <para>串列覽線有許多不同的類型，兩種最常見的是 null-modem 纜線和標準 
	<acronym>RS-232</acronym> 纜線。你的串列硬體文件應該會描述需要哪一種類型的纜線。</para>

      <para>這兩種類型的線差別在於內部的線如何到連接頭，每一條線表示一個預先定義的訊號，整理在
	<xref linkend="serialcomms-signal-names"/>。一個標準的串列纜線直接傳送全部<acronym>RS-232C</acronym> 訊號。例如，纜線其中一端的<quote>Transmitted
	  Data</quote> 連到另一端的<quote>Transmitted Data</quote>。 這是用連接 modem 到 &os; 系統的纜線類型，對於某些終端也是最適合的
	</para>

      <para>一個 null-modem 纜線轉換成成連接頭一端的<quote>Transmitted
	  Data</quote> 連接到另一端的<quote>Received Data</quote>。連接頭可以是<acronym>DB-25</acronym>，不然就是<acronym>DB-9</acronym>。
	  <para>

      <para>null-modem 纜線可以使用<xref linkend="nullmodem-db25"/>,
	  <xref linkend="nullmodem-db9"/>和<xref
	  linkend="nullmodem-db9-25"/>的腳位對應來製作。當標準規定腳位 1 直接對接，<quote>Protective
	  Ground</quote> 線時常被省略。在一些不同的設定下，有一些終端只有使用到腳位 2、3、7。nals
	  如果有疑惑，請參考串列硬體的文件。
	  </para>

      <indexterm>
	<primary>null-modem cable</primary>
      </indexterm>

      <table frame="none" pgwide="1"
	xml:id="serialcomms-signal-names">
	<title><acronym>RS-232C</acronym> Signal Names</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry align="left">Acronyms</entry>
	      <entry align="left">Names</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><acronym>RD</acronym></entry>
	      <entry>Received Data</entry>
	    </row>

	    <row>
	      <entry><acronym>TD</acronym></entry>
	      <entry>Transmitted Data</entry>
	    </row>

	    <row>
	      <entry><acronym>DTR</acronym></entry>
	      <entry>Data Terminal Ready</entry>
	    </row>

	    <row>
	      <entry><acronym>DSR</acronym></entry>
	      <entry>Data Set Ready</entry>
	    </row>

	    <row>
	      <entry><acronym>DCD</acronym></entry>
	      <entry>Data Carrier Detect</entry>
	    </row>

	    <row>
	      <entry><acronym>SG</acronym></entry>
	      <entry>Signal Ground</entry>
	    </row>

	    <row>
	      <entry><acronym>RTS</acronym></entry>
	      <entry>Request to Send</entry>
	    </row>

	    <row>
	      <entry><acronym>CTS</acronym></entry>
	      <entry>Clear to Send</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db25">
	<title>DB-25 to DB-25 Null-Modem Cable</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>SG</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>RD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>RTS</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>20</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>20</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db9">
	<title>DB-9 to DB-9 Null-Modem Cable</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>RD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>1</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>SG</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>1</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>RTS</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db9-25">
	<title>DB-9 to DB-25 Null-Modem Cable</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>RD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>SG</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>1</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>RTS</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <note>
	<para>When one pin at one end connects to a pair of pins at
	  the other end, it is usually implemented with one short wire
	  between the pair of pins in their connector and a long wire
	  to the other single pin.</para>
      </note>

      <para>串列阜是資料在 &os; 主機電腦和終端傳輸經過的設備。存在好幾種串列阜，在購買或打造一條纜線之前，確定它能適合終端和&os;系統上的串列阜。
	</para>

      <para>大部分的終端提供<acronym>DB-25</acronym>串列阜。
	個人電腦可能提供<acronym>DB-25</acronym>或
	<acronym>DB-9</acronym>串列阜。一個多阜的串列卡可能提供
	<acronym>RJ-12</acronym>或<acronym>RJ-45/</acronym>
	串列阜。請見該串列阜硬體隨附的文件，或者肉眼辨識串列阜的類別。</para>

      <para>在 &os;，每一個串列阜需透過在
	 <filename>/dev</filename>下的節點去存取。有兩種不同的節點:
	  </para>

      <itemizedlist>
	<listitem>
	  <para>Call-in ports 命名為
	    <filename>/dev/ttyu<replaceable>N</replaceable></filename>
	    ，而<replaceable>N</replaceable> 是阜的號碼，從零開始。
	    如果終端連接到第一個串列阜 (<filename>COM1</filename>)，使用
	    <filename>/dev/ttyu0</filename>與該終端通訊。
	    如果終端正在第二個串列阜上 (<filename>COM2</filename>)，則使用
	    <filename>/dev/ttyu1</filename>，以此類推。一般來說，
	    call-in 阜　被用在終端。為了正常運作，Call-in 阜要求串列線具備<quote>Data　Carrier Detect</quote> 訊號。
		</para>
	</listitem>

	<listitem>
	  <para>Call-ou 阜命名為
	    <filename>/dev/cuau<replaceable>N</replaceable></filename>
	    on &os; versions 10.x and higher and
	    <filename>/dev/cuad<replaceable>N</replaceable></filename>
	    on &os; versions 9.x and lower.  Call-out 阜通常不用在終端，而是用在 modem。Call-out 阜可以被用在當串列線或者終端不支援<quote>Data Carrier Detect</quote>訊號。
	  </para>
	</listitem>
      </itemizedlist>

      <para>&os; also provides initialization devices
	(<filename>/dev/ttyu<replaceable>N</replaceable>.init</filename>
	and
	<filename>/dev/cuau<replaceable>N</replaceable>.init</filename>
	or
	<filename>/dev/cuad<replaceable>N</replaceable>.init</filename>)
	and locking devices
	(<filename>/dev/ttyu<replaceable>N</replaceable>.lock</filename>
	and
	<filename>/dev/cuau<replaceable>N</replaceable>.lock</filename>
	or
	<filename>/dev/cuad<replaceable>N</replaceable>.lock</filename>).
	The initialization devices are used to initialize
	communications port parameters each time a port is opened,
	such as <literal>crtscts</literal> for modems which use
	<literal>RTS/CTS</literal> signaling for flow control.  The
	locking devices are used to lock flags on ports to prevent
	users or programs changing certain parameters.  Refer to
	&man.termios.4;, &man.sio.4;, and &man.stty.1; for information
	on terminal settings, locking and initializing devices, and
	setting terminal options, respectively.</para>
    </sect2>

    <sect2 xml:id="serial-hw-config">
      <title>串列阜設定</title>

      <para>預設下，&os; 支援四種已知的串列阜<filename>COM1</filename>、
	<filename>COM2</filename>、<filename>COM3</filename>、
	<filename>COM4</filename>。  &os; 也支援 dumb multi-port
	串列介面卡，例如：　BocaBoard 1008 and 2016，還有 Digiboard 製造的智慧多阜卡。然而，預設核心只會搜尋標準<filename>COM</filename>阜。
	 </para>

 	<para>  
	為了看出系統是不是可辨識出串列阜，搜尋系統開機訊息中與
	<literal>uart</literal>有關的部份:</para>

      <screen>&prompt.root; <userinput>grep uart /var/run/dmesg.boot</userinput></screen>

      <para>
	  If the system does not recognize all of the needed serial
	ports, additional entries can be added to
	<filename>/boot/device.hints</filename>.  This file already
	contains <literal>hint.uart.0.*</literal> entries for
	<filename>COM1</filename> and <literal>hint.uart.1.*</literal>
	entries for <filename>COM2</filename>.  When adding a port
	entry for <filename>COM3</filename> use
	<literal>0x3E8</literal>, and for <filename>COM4</filename>
	use <literal>0x2E8</literal>.  Common <acronym>IRQ</acronym>
	addresses are <literal>5</literal> for
	<filename>COM3</filename> and <literal>9</literal> for
	<filename>COM4</filename>.</para>

      <indexterm><primary><filename>ttyu</filename></primary></indexterm>
      <indexterm><primary><filename>cuau</filename></primary></indexterm>

      <para>為了決定 Port 使用的預設終端<filename>COM2</filename>設定，指定它的設備名字。下面的範例決定在 <filename>COM2</filename> 上的 call-in port 設定:
	  </para>
      <screen>&prompt.root; <userinput>stty -a -f /dev/<replaceable>ttyu1</replaceable></userinput></screen>

      <para>系統層級的串列設備初始化被<filename>/etc/rc.d/serial</filename>控制。這個檔案影響串列裝置的預設設定。為了改變一個裝置的設定， 
	  可以利用 <command>stty</command>。預設下，設定改變的影響只有在裝置關閉前有效，當裝置被重新開啟，設定將回到預設值。
	  為了永久地改變預設設定，開啟並且調整 init 裝置的設定。例如，開啟<filename>ttyu5</filename>的<option>CLOCAL</option>模式、8 bit通訊、<option>XON/XOFF</option>流量控制，輸入:
	  </para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

      <indexterm>
	<primary>rc files</primary>
	<secondary><filename>rc.serial</filename></secondary>
      </indexterm>

      <para>為了防止應用程式試圖想改變設定，可以對 locking 裝置調整。
		例如，為了將<filename>ttyu5</filename>固定在57600&nbsp;bps，輸入：
	  </para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.lock 57600</userinput></screen>

      <para>從今以後，任何想要開啟並改變<filename>ttyu5</filename>速率的程式，將一直停在 57600&nbsp;bps。
	  </para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info>
    <title>Terminals</title>

      <authorgroup>
	<author>
	<personname>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	</personname>
	  <contrib>Contributed by </contrib>
    <!--in July 1996 -->
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>terminals</primary></indexterm>

    <para>當不在電腦前或已連線的電腦網路情況下，終端提供一個方便而且低花費的方法去存取&os;系統，本節描述如何使用終端與&os;互動
	</para>

    <para>最初的 &unix; 並沒有 console。反而，使用者透過連到電腦串列阜的終端登入並執行程式
	</para>

    <para>至今幾乎每一個&unix;-like作業系統仍保留透過串列阜建立一個登入連線的能力，包括&os;，
	透過附屬在閒置的串列阜終端，使用者可以登入，並且執行跟在 console 或者一個 <command>xterm</command>視窗一模一樣的文字程式，
    </para>

    <para>許多終端可以被連結到&os;系統。一個叫老的備用電腦可以被當成一個終端，連接到能力比較強的 &os;，這將使單人電腦變成多人電腦。
    </para>

    <para>&os; 支援三種型態的終端:</para>

    <variablelist>
      <varlistentry>
	<term>Dumb terminals</term>
	<listitem>
	  <para>Dumb terminals are specialized hardware that connect
	    to computers over serial lines.  They are called
	    <quote>dumb</quote> because they have only enough
	    computational power to display, send, and receive text.
	    No programs can be run on these devices.  Instead, dumb
	    terminals connect to a computer that runs the needed
	    programs.</para>

	  <para>有上千種各種製造商的簡易終端，其中大部分可以與 &os; 正常互動。有些高階的終端甚至可以顯示圖形，但是只有某些軟體套件可以使用到這些進階功能。
		</para>

	  <para>Dumb terminals 在一些不需要圖形應用程式的工作環境非常熱門功能。
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Computers Acting as Terminals</term>
	<listitem>
	  <para>從簡易終端有剛剛好足夠的能力在顯示、傳送和接收文字，任何閒置的電腦可以成為一個簡易終端，只需要一條適當地纜線與在電腦上執行<firstterm>終端模擬</firstterm>軟體</para>

	  <para>這個設定檔將非常有用，例如，如果有一個使用者在忙於&os;系統的 console，同時，其他使用者可以透過效能中等的電腦透過終端到 &os; 系統做文字處理，
		</para>
	  <para>
	  在 base 系統至少有兩個通用工具可以用進行串列連線:
	    &man.cu.1; 和 &man.tip.1;。</para>

	  <para>例如，為了從 &os; 客戶端系統透過串列連到其他系統:
	  </para>

	  <screen>&prompt.root; <userinput>cu -l <replaceable>serial-port-device</replaceable></userinput></screen>

	  <para>將 <replaceable>serial-port-device</replaceable>替換成連接的串列阜裝置名稱，
	  在些裝置在 &os; versions 10.x 以上叫 <filename>/dev/cuau<replaceable>N</replaceable></filename>，
		在 &os; versions 9.x 以下叫<filename>/dev/cuad<replaceable>N</replaceable></filename>。
	   在任何一種情況，<replaceable>N</replaceable>是串列阜號碼，從零開始。
	   這意味著在 &os; <filename>COM1</filename> 對應到<filename>/dev/cuau0</filename>或<filename>/dev/cuad0</filename>。
		</para>

	  <para>額外的應用程式可以透過 Ports Collection 取得，例如
	    <package>comms/minicom</package>。</para>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>X Terminals</term>
	<listitem>
	  <para>X terminals 是可取得終端中算是比較複雜的。are the most sophisticated kind of
	    terminal available.  相較於連到串列阜，Instead of connecting to a serial
	    port, they usually connect to a network like Ethernet.
	    相較於只能顯示文字的程式，他們可以顯示任何<application>&xorg;</application>程式。i
	</para>

	  <para>本章不包涵 X 終端的建立、設定與使用。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2 xml:id="term-config">
      <title>Terminal Configuration</title>

      <para>本節描述如何設定在 &os; 系統啟用串列終端的登入連線。它解設系統認得終端連結的串列阜並且終端與正確的纜線連接。
	</para>

      <para>在 &os;， <command>init</command> 讀取
	<filename>/etc/ttys</filename> 並且在可用的終端執行
	<command>getty</command> 程序。<command>getty</command> 程序是負責讀取登入名稱並執行 <command>login</command> 程式。
	&os; 系統允許的 Ports 列在<filename>/etc/ttys</filename>。例如，第一個虛擬 console，<filename>ttyv0</filename>，
	有一個項目在這個檔案，允許在這個 console 登入。
	這個檔案也包含其他虛擬 console、序列阜、pseudo-ttys。以硬體終端而言，串列阜的<filename>/dev</filename>項目被列在檔案中，但名字不包含 <literal>/dev</literal> 部份。
	例如，<filename>/dev/ttyv0</filename>被列為<literal>ttyv0</literal>。
	</para>

      <para>預設 <filename>/etc/ttys</filename> 設定前四個串列阜的支援，<filename>ttyu0</filename>到<filename>ttyu3</filename>:
	</para>

      <programlisting>ttyu0   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu1   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu2   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu3   "/usr/libexec/getty std.9600"   dialup  off secure</programlisting>

      <para>當連接一個終端到其中一個阜，修改預設的項目去設定所需的速度和終端型態，將裝置設定為 <literal>on</literal> 來啟用，如果有必要，
	  改變阜的<literal>secure</literal>設定。如果終端被連接到其他阜，替那個阜增加一筆項目。
	</para>

      <para><xref linkend="ex-etc-ttys"/> 設定兩個終端在
	<filename>/etc/ttys</filename>.  第一筆項目設定一個連接到 <filename>COM2</filename> 的 Wyse-50。第二筆項目設定一個使用<application>Procomm</application>終端軟體模擬
	 VT-100 老電腦的終端。這個電腦被連接到一個多串列阜卡的第五個阜。
	  </para>

      <example xml:id="ex-etc-ttys">
	<title>Configuring Terminal Entries</title>

	<programlisting>ttyu1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure</programlisting>

	<calloutlist>
	  <callout arearefs="co-ttys-line1col1">
	    <para>第一個欄位指定串列終端的裝置名稱。</para>
	  </callout>

	  <callout arearefs="co-ttys-line1col2">
	    <para>第二個欄位用來告訴<command>getty</command>去初始化，開啟裝置，設定裝置速度，提示使用者給予一個使用者名稱，並且執行<command>login</command>程式。
		額外選項<firstterm>getty type</firstterm>設定終端線的特性，如<acronym>bps</acronym>速率和 parity。可用的 getty 型態被列在<filename>/etc/gettytab</filename>。
	      在大部分情況下，以<literal>std</literal> 開頭的 getty 型態名稱將作為硬體終端使用，這些項目忽略 parity，有一個
		  <literal>std</literal> 項目作為代表每一個從 100 到 115200 的 <acronym>bps</acronym>速率。更多訊息可參考&man.gettytab.5;。

	    <para>當設定一個 getty 的型態，確保符合終端使用的通訊設定。例如，Wyse-50 使用 no parity　和運作在38400&nbsp;bps　下。
		而那台老舊的電腦使用 no parity 並且運作在 19200&nbsp;bps 下。
	     </para>
	  </callout>

	  <callout arearefs="co-ttys-line1col3">
	    <para>The third field is the type of terminal.  For
	      dial-up ports, <literal>unknown</literal> or
	      <literal>dialup</literal> is typically used since users
	      may dial up with practically any type of terminal or
	      software.  Since the terminal type does not change for
	      hardwired terminals, a real terminal type from
	      <filename>/etc/termcap</filename> can be specified.  For
	      this example, the Wyse-50 uses the real terminal type
	      while the computer running
	      <application>Procomm</application> is set to emulate a
	      VT-100.</para>
	  </callout>

	  <callout arearefs="co-ttys-line1col4">
	    <para>The fourth field specifies if the port should be
	      enabled.  To enable logins on this port, this field must
	      be set to <literal>on</literal>.</para>
	  </callout>

	  <callout arearefs="co-ttys-line1col5">
	    <para>The final field is used to specify whether the port
	      is secure.  Marking a port as <literal>secure</literal>
	      means that it is trusted enough to allow <systemitem
		class="username">root</systemitem> to login from that
	      port.  Insecure ports do not allow <systemitem
		class="username">root</systemitem> logins.  On an
	      insecure port, users must login from unprivileged
	      accounts and then use <command>su</command> or a similar
	      mechanism to gain superuser privileges, as described in
	      <xref linkend="users-superuser"/>.  For security
	      reasons, it is recommended to change this setting to
	      <literal>insecure</literal>.</para>
	  </callout>
	</calloutlist>
      </example>

      <para>對<filename>/etc/ttys</filename> 做任何改變之後, 送一個 SIGHUP (hangup) 訊號給 <command>init</command> 程序，強制它重新讀取他的設定檔:
	</para>

      <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

      <para>自從 <command>init</command> 是第一個系統執行的程式開始，它的程序 <acronym>ID</acronym> 一直為 <literal>1</literal>。</para>

      <para>如果每一件事情都有正確設定，纜線都有接好，每一個終端機都有上電，一個 <command>getty</command> 程序現在應該已經在每一個終端執行，而且登入提示應該出現在每一個終端前。
	</para>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>Troubleshooting the Connection</title>

      <para>Even with the most meticulous attention to detail,
	something could still go wrong while setting up a terminal.
	Here is a list of common symptoms and some suggested
	fixes.</para>

      <para>如果沒有登入提示出現，確定終端機是有被接上並且上電。如果它是一個個人電腦當成終端機，確定終端模擬軟體有開啟正確的序列阜。
	</para>

      <para>確定纜線有被牢固的接在終端機和 &os; 電腦之間。確定纜線的種類是正確的。
	</para>

      <para>確定終端機和 &os; 可以適合 <acronym>bps</acronym> 速率和 parity 設定。以視訊撥放的終端機，確定對比跟亮度控制是 turn up。如果是一個列印終端，確保紙張跟墨水有正確放置。
	</para>

      <para>使用 <command>ps</command> 來確保
	<command>getty</command> 程序正在執行中並且提供終端服務。舉例來說，下列顯示有ㄧ個
	<command>getty</command> 正在使用第二個序列埠
	<filename>ttyu1</filename>，並且使用在<filename>/etc/gettytab</filename>內的<literal>std.38400</literal>項目:
	</para>

      <screen>&prompt.root; <userinput>ps -axww|grep ttyu</userinput>
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

      <para>如果沒有任何 <command>getty</command> 程序正在執行，確保該序列埠在 <filename>/etc/ttys</filename> 有被啟用。
	  修改完 <filename>/etc/ttys</filename> 記得執行 <command>kill -HUP 1</command> 
	  </para>

      <para>如果 <command>getty</command> 程序正在執行但是終端仍然沒有顯示燈入提示
	  ，或者有顯示提示但是不能接受任何鍵盤輸入，終端機或纜線可能不支援硬體交握，
	  試試看將 <filename>/etc/ttys</filename> 的該項目從 <literal>std.38400</literal> 改成 <literal>3wire.38400</literal>，修改完 <filename>/etc/ttys</filename> 之後
	  ，執行 <command>kill -HUP 1</command>。<literal>3wire</literal> 項目跟 <literal>std</literal> 相似，但是忽略硬體交握。當使用 <literal>3wire</literal> 
	  來防止緩衝區溢位，它的 baud 率可能需要降低，或者啟用軟體流量控制。
	</para>

      <para>如果出現的是垃圾訊息而不是登入提示，確保終端機和 &os; 適合使用 <acronym>bps</acronym> 速率和 parity 設定
	檢查 <command>getty</command> 程序來確保使用的是正確的 <replaceable>getty</replaceable> 類型。如果不是，編輯
	<filename>/etc/ttys</filename> 然後執行 <command>kill -HUP 1</command>.</para>

      <para>如果出現重複字元和密碼被顯示，更換終端機或者終端模擬軟體，from <quote>half duplex</quote> or <quote>local 
	  echo</quote> to <quote>full duplex.</quote></para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info>
    <title>Dial-in Service</title>

      <authorgroup>
	<author>
	<personname>
	<firstname>Guy</firstname>
	  <surname>Helmer</surname>
	  </personname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	<personname>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  </personname>
	  <contrib>Additions by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>dial-in service</primary></indexterm>

    <para>Configuring a &os; system for dial-in service is similar to
      configuring terminals, except that modems are used instead of
      terminal devices.  &os; supports both external and internal
      modems.</para>

    <para>External modems are more convenient because they often can
      be configured via parameters stored in non-volatile
      <acronym>RAM</acronym> and they usually provide lighted
      indicators that display the state of important
      <acronym>RS-232</acronym> signals, indicating whether the modem
      is operating properly.</para>

    <para>Internal modems usually lack non-volatile
      <acronym>RAM</acronym>, so their configuration may be limited to
      setting <acronym>DIP</acronym> switches.  If the internal modem
      has any signal indicator lights, they are difficult to view when
      the system's cover is in place.</para>

    <indexterm><primary>modem</primary></indexterm>

    <para>When using an external modem, a proper cable is needed.  A
      standard <acronym>RS-232C</acronym> serial cable should
      suffice.</para>

    <para>&os; needs the <acronym>RTS</acronym> and
      <acronym>CTS</acronym> signals for flow control at speeds above
      2400&nbsp;bps, the <acronym>CD</acronym> signal to detect when a
      call has been answered or the line has been hung up, and the
      <acronym>DTR</acronym> signal to reset the modem after a session
      is complete.  Some cables are wired without all of the needed
      signals, so if a login session does not go away when the line
      hangs up, there may be a problem with the cable.  Refer to <xref
	linkend="term-cables-null"/> for more information about these
      signals.</para>

    <para>Like other &unix;-like operating systems, &os; uses the
      hardware signals to find out when a call has been answered or a
      line has been hung up and to hangup and reset the modem after a
      call.  &os; avoids sending commands to the modem or watching for
      status reports from the modem.</para>

    <para>&os; supports the <acronym>NS8250</acronym>,
      <acronym>NS16450</acronym>, <acronym>NS16550</acronym>, and
      <acronym>NS16550A</acronym>-based <acronym>RS-232C</acronym>
      (<acronym>CCITT</acronym> V.24) communications interfaces.  The
      8250 and 16450 devices have single-character buffers.  The 16550
      device provides a 16-character buffer, which allows for better
      system performance.  Bugs in plain 16550 devices prevent the use
      of the 16-character buffer, so use 16550A devices if possible.
      Because single-character-buffer devices require more work by the
      operating system than the 16-character-buffer devices,
      16550A-based serial interface cards are preferred.  If the
      system has many active serial ports or will have a heavy load,
      16550A-based cards are better for low-error-rate
      communications.</para>

    <para>The rest of this section demonstrates how to configure a
      modem to receive incoming connections, how to communicate with
      the modem, and offers some troubleshooting tips.</para>

    <sect2 xml:id="dialup-ttys">
      <title>Modem Configuration</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>As with terminals, <command>init</command> spawns a
	<command>getty</command> process for each configured serial
	port used for dial-in connections.  When a user dials the
	modem's line and the modems connect, the <quote>Carrier
	  Detect</quote> signal is reported by the modem.  The kernel
	notices that the carrier has been detected and instructs
	<command>getty</command> to open the port and display a
	<prompt>login:</prompt> prompt at the specified initial line
	speed.  In a typical configuration, if garbage characters are
	received, usually due to the modem's connection speed being
	different than the configured speed, <command>getty</command>
	tries adjusting the line speeds until it receives reasonable
	characters.  After the user enters their login name,
	<command>getty</command> executes <command>login</command>,
	which completes the login process by asking for the user's
	password and then starting the user's shell.</para>

      <indexterm>
	<primary><command>/usr/bin/login</command></primary>
      </indexterm>

      <para>There are two schools of thought regarding dial-up modems.
	One confiuration method is to set the modems and systems so
	that no matter at what speed a remote user dials in, the
	dial-in <acronym>RS-232</acronym> interface runs at a locked
	speed.  The benefit of this configuration is that the remote
	user always sees a system login prompt immediately.  The
	downside is that the system does not know what a user's true
	data rate is, so full-screen programs like
	<application>Emacs</application> will not adjust their
	screen-painting methods to make their response better for
	slower connections.</para>

      <para>The second method is to configure the
	<acronym>RS-232</acronym> interface to vary its speed based on
	the remote user's connection speed.  Because
	<command>getty</command> does not understand any particular
	modem's connection speed reporting, it gives a
	<prompt>login:</prompt> message at an initial speed and
	watches the characters that come back in response.  If the
	user sees junk, they should press <keycap>Enter</keycap> until
	they see a recognizable prompt.  If the data rates do not
	match, <command>getty</command> sees anything the user types
	as junk, tries the next speed, and gives the
	<prompt>login:</prompt> prompt again.  This procedure normally
	only takes a keystroke or two before the user sees a good
	prompt.  This login sequence does not look as clean as the
	locked-speed method, but a user on a low-speed connection
	should receive better interactive response from full-screen
	programs.</para>

      <para>When locking a modem's data communications rate at a
	particular speed, no changes to
	<filename>/etc/gettytab</filename> should be needed.  However,
	for a matching-speed configuration, additional entries may be
	required in order to define the speeds to use for the modem.
	This example configures a 14.4&nbsp;Kbps modem with a top
	interface speed of 19.2&nbsp;Kbps using 8-bit, no parity
	connections.  It configures <command>getty</command> to start
	the communications rate for a V.32bis connection at
	19.2&nbsp;Kbps, then cycles through 9600&nbsp;bps,
	2400&nbsp;bps, 1200&nbsp;bps, 300&nbsp;bps, and back to
	19.2&nbsp;Kbps.  Communications rate cycling is implemented
	with the <literal>nx=</literal> (next table) capability.  Each
	line uses a <literal>tc=</literal> (table continuation) entry
	to pick up the rest of the settings for a particular data
	rate.</para>

      <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

      <para>For a 28.8&nbsp;Kbps modem, or to take advantage of
	compression on a 14.4&nbsp;Kbps modem, use a higher
	communications rate, as seen in this example:</para>

      <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

      <para>For a slow <acronym>CPU</acronym> or a heavily loaded
	system without 16550A-based serial ports, this configuration
	may produce <errorname>sio</errorname>
	<quote>silo</quote> errors at 57.6&nbsp;Kbps.</para>

      <indexterm>
	<primary><filename>/etc/ttys</filename></primary>
      </indexterm>

      <para>The configuration of <filename>/etc/ttys</filename> is
	similar to <xref linkend="ex-etc-ttys"/>, but a different
	argument is passed to <command>getty</command> and
	<literal>dialup</literal> is used for the terminal type.
	Replace <replaceable>xxx</replaceable> with the process
	<command>init</command> will run on the device:</para>

      <programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

      <para>The <literal>dialup</literal> terminal type can be
	changed.  For example, setting <literal>vt102</literal> as the
	default terminal type allows users to use
	<acronym>VT102</acronym> emulation on their remote
	systems.</para>

      <para>For a locked-speed configuration, specify the speed with
	a valid type listed in <filename>/etc/gettytab</filename>.
	This example is for a modem whose port speed is locked at
	19.2&nbsp;Kbps:</para>

      <programlisting>ttyu0   "/usr/libexec/getty std.<replaceable>19200</replaceable>"   dialup on</programlisting>

      <para>In a matching-speed configuration, the entry needs to
	reference the appropriate beginning <quote>auto-baud</quote>
	entry in <filename>/etc/gettytab</filename>.  To continue the
	example for a matching-speed modem that starts at
	19.2&nbsp;Kbps, use this entry:</para>

      <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>

      <para>After editing <filename>/etc/ttys</filename>, wait until
	the modem is properly configured and connected before
	signaling <command>init</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

      <indexterm>
	<primary>rc files</primary>
	<secondary><filename>rc.serial</filename></secondary>
      </indexterm>

      <para>High-speed modems, like <acronym>V.32</acronym>,
	<acronym>V.32bis</acronym>, and <acronym>V.34</acronym>
	modems, use hardware (<literal>RTS/CTS</literal>) flow
	control.  Use <command>stty</command> to set the hardware flow
	control flag for the modem port.  This example sets the
	<varname>crtscts</varname> flag on <filename>COM2</filename>'s
	dial-in and dial-out initialization devices:</para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu1.init crtscts</userinput>
&prompt.root; <userinput>stty -f /dev/cuau1.init crtscts</userinput></screen>
    </sect2>

<!--
Comment out for now. If this is still needed, the example should
either be updated or the section modified to be more generic
e.g. refer to the modem's manual
    <sect2>
      <title>Modem Settings</title>

      <para>For a modem whose parameters may be permanently set in
	non-volatile RAM, a terminal program such as
	<command>tip</command> can be used to set the parameters.
	Connect to the modem using the same communications speed as
	the initial speed <command>getty</command> will use and
	configure the modem's non-volatile RAM to match these
	requirements:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>CD</acronym> asserted when connected.</para>
	</listitem>

	<listitem>
	  <para><acronym>DTR</acronym> asserted for operation and
	    dropping DTR hangs up the line and resets the
	    modem.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> transmitted data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Disable <acronym>XON/XOFF</acronym> flow
	    control.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> received data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (no result codes).</para>
	</listitem>

	<listitem>
	  <para>No command echo.</para>
	</listitem>
      </itemizedlist>

      <para>Read the documentation for the modem to find out
	which commands and/or DIP switch settings are needed.</para>

      <para>For example, to set the above parameters on a &usrobotics;
	&sportster; 14,400 external modem, give these commands to
	the modem:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Other settings can be adjusted in the modem, such as
	whether it will use V.42bis and/or MNP5 compression.</para>

      <para>The &usrobotics; &sportster; 14,400 external modem also
	has some DIP switches that need to be set.  Other modems,
	may need these settings:</para>

      <itemizedlist>
	<listitem>
	  <para>Switch 1: UP &mdash; DTR Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 2: N/A (Verbal Result Codes/Numeric Result
	    Codes)</para>
	</listitem>

	<listitem>
	  <para>Switch 3: UP &mdash; Suppress Result Codes</para>
	</listitem>

	<listitem>
	  <para>Switch 4: DOWN &mdash; No echo, offline
	    commands</para>
	</listitem>

	<listitem>
	  <para>Switch 5: UP &mdash; Auto Answer</para>
	</listitem>

	<listitem>
	  <para>Switch 6: UP &mdash; Carrier Detect Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 7: UP &mdash; Load NVRAM Defaults</para>
	</listitem>

	<listitem>
	  <para>Switch 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>Result codes should be disabled/suppressed for dial-up
	modems to avoid problems that can occur if
	<command>getty</command> mistakenly gives a
	<prompt>login:</prompt> prompt to a modem that is in command
	mode and the modem echoes the command or returns a result
	code.  This sequence can result in an extended, silly
	conversation between <command>getty</command> and the
	modem.</para>

      <para>For a locked-speed configuration, configure the modem to
	maintain a constant modem-to-computer data rate independent
	of the communications rate.  On a &usrobotics; &sportster;
	14,400 external modem, these commands will lock the
	modem-to-computer data rate at the speed used to issue the
	commands:</para>

      <programlisting>ATZ
AT&amp;B1&amp;W</programlisting>

      <para>For a variable-speed configuration, configure the modem
	to adjust its serial port data rate to match the incoming
	call rate.  On a &usrobotics; &sportster; 14,400 external
	modem, these commands will lock the modem's error-corrected
	data rate to the speed used to issue the commands, while
	allowing the serial port rate to vary for
	non-error-corrected connections:</para>

      <programlisting>ATZ
AT&amp;B2&amp;W</programlisting>

      <para>Most high-speed modems provide commands to view the
	modem's current operating parameters in a somewhat
	human-readable fashion.  On the &usrobotics; &sportster;
	14,400 external modem, <command>ATI5</command> displays the
	settings that are stored in the non-volatile RAM.  To see the
	true operating parameters of the modem, as influenced by the
	modem's DIP switch settings, use <command>ATZ</command> and
	then <command>ATI4</command>.</para>

      <para>For a different brand of modem, check the modem's manual
	to see how to double-check the modem's configuration
	parameters.</para>
    </sect2>
    -->

    <sect2>
      <title>Troubleshooting</title>

      <para>This section provides a few tips for troubleshooting a
	dial-up modem that will not connect to a &os; system.</para>

      <para>Hook up the modem to the &os; system and boot the system.
	If the modem has status indication lights, watch to see
	whether the modem's <acronym>DTR</acronym> indicator lights
	when the <prompt>login:</prompt> prompt appears on the
	system's console.  If it lights up, that should mean that &os;
	has started a <command>getty</command> process on the
	appropriate communications port and is waiting for the modem
	to accept a call.</para>

      <para>If the <acronym>DTR</acronym> indicator does not light,
	login to the &os; system through the console and type
	<command>ps ax</command> to see if &os; is running a
	<command>getty</command> process on the correct port:</para>

      <screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 <replaceable>ttyu0</replaceable></screen>

      <para>If the second column contains a <literal>d0</literal>
	instead of a <literal>??</literal> and the modem has not
	accepted a call yet, this means
	that <command>getty</command> has completed its open on the
	communications port.  This could indicate a problem with the
	cabling or a misconfigured modem because
	<command>getty</command> should not be able to open the
	communications port until the carrier detect signal has been asserted by
	the modem.</para>

      <para>If no <command>getty</command> processes are waiting to
	open the port, double-check that the entry for the port is
	correct in <filename>/etc/ttys</filename>.  Also, check
	<filename>/var/log/messages</filename> to see if there are
	any log messages from <command>init</command> or
	<command>getty</command>.</para>

      <para>Next, try dialing into the system.  Be sure to use 8 bits,
	no parity, and 1 stop bit on the remote system.  If a prompt
	does not appear right away, or the prompt shows garbage, try
	pressing <keycap>Enter</keycap> about once per second.  If
	there is still no <prompt>login:</prompt> prompt,
	try sending a <command>BREAK</command>.  When using a
	high-speed modem, try dialing again after locking the
	dialing modem's interface speed.</para>

      <para>If there is still no <prompt>login:</prompt> prompt, check
	<filename>/etc/gettytab</filename> again and double-check
	that:</para>

      <itemizedlist>
	<listitem>
	  <para>The initial capability name specified in the entry in
	    <filename>/etc/ttys</filename> matches the name of a
	    capability in <filename>/etc/gettytab</filename>.</para>
	</listitem>

	<listitem>
	  <para>Each <literal>nx=</literal> entry matches another
	    <filename>gettytab</filename> capability name.</para>
	</listitem>

	<listitem>
	  <para>Each <literal>tc=</literal> entry matches another
	    <filename>gettytab</filename> capability name.</para>
	</listitem>
      </itemizedlist>

      <para>If the modem on the &os; system will not answer, make
	sure that the modem is configured to answer the phone when
	<acronym>DTR</acronym> is asserted.  If the modem seems to be
	configured correctly, verify that the
	<acronym>DTR</acronym> line is asserted by checking the
	modem's indicator lights.</para>

      <para>If it still does not work, try sending an email
	to the &a.questions; describing the modem and the
	problem.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialout">
    <title>Dial-out 服務</title>

    <indexterm><primary>dial-out service</primary></indexterm>

    <para>The following are tips for getting the host to connect over
      the modem to another computer.  This is appropriate for
      establishing a terminal session with a remote host.</para>

    <para>This kind of connection can be helpful to get a file on the
      Internet if there are problems using PPP.  If PPP is not
      working, use the terminal session to FTP the needed file.  Then
      use zmodem to transfer it to the machine.</para>

    <sect2 xml:id="hayes-unsupported">
      <title>Using a Stock Hayes Modem</title>

      <para>A generic Hayes dialer is built into
	<command>tip</command>.  Use <literal>at=hayes</literal> in
	<filename>/etc/remote</filename>.</para>

      <para>The Hayes driver is not smart enough to recognize some of
	the advanced features of newer modems messages like
	<literal>BUSY</literal>, <literal>NO DIALTONE</literal>, or
	<literal>CONNECT 115200</literal>.  Turn those messages off
	when using <command>tip</command> with
	<command>ATX0&amp;W</command>.</para>

      <para>The dial timeout for <command>tip</command> is 60
	seconds.  The modem should use something less, or else
	<command>tip</command> will think there is a communication
	problem.  Try <command>ATS7=45&amp;W</command>.</para>
    </sect2>

    <sect2 xml:id="direct-at">
      <title>Using <literal>AT</literal> Commands</title>

      <indexterm>
	<primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Create a <quote>direct</quote> entry in
	<filename>/etc/remote</filename>.  For example, if the modem
	is hooked up to the first serial port,
	<filename>/dev/cuau0</filename>, use the following
	line:</para>

      <programlisting>cuau0:dv=/dev/cuau0:br#19200:pa=none</programlisting>

      <para>Use the highest <acronym>bps</acronym> rate the modem
	supports in the <literal>br</literal> capability.  Then, type
	<command>tip cuau0</command> to connect to the modem.</para>

      <para>Or, use <command>cu</command> as <systemitem
	  class="username">root</systemitem> with the following
	      command:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> is the serial port, such
	as <filename>/dev/cuau0</filename>, and
	<replaceable>speed</replaceable> is the speed, such as
	<literal>57600</literal>.  When finished entering the AT
	commands, type <command>~.</command> to exit.</para>
    </sect2>

    <sect2 xml:id="gt-failure">
      <title>The <literal>@</literal> Sign Does Not Work</title>

      <para>The <literal>@</literal> sign in the phone number
	capability tells <command>tip</command> to look in
	<filename>/etc/phones</filename> for a phone number.  But, the
	<literal>@</literal> sign is also a special character in
	capability files like <filename>/etc/remote</filename>, so it
	needs to be escaped with a backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 xml:id="dial-command-line">
      <title>Dialing from the Command Line</title>

      <para>Put a <quote>generic</quote> entry in
	<filename>/etc/remote</filename>.  For example:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>This should now work:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Users who prefer <command>cu</command> over
	<command>tip</command>, can use a generic
	<literal>cu</literal> entry:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>and type:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 xml:id="set-bps">
      <title>Setting the <acronym>bps</acronym> Rate</title>

      <para>Put in an entry for <literal>tip1200</literal> or
	<literal>cu1200</literal>, but go ahead and use whatever
	<acronym>bps</acronym> rate is appropriate with the
	<literal>br</literal> capability.
	<command>tip</command> thinks a good default is 1200&nbsp;bps
	which is why it looks for a <literal>tip1200</literal> entry.
	1200&nbsp;bps does not have to be used, though.</para>
    </sect2>

    <sect2 xml:id="terminal-server">
      <title>Accessing a Number of Hosts Through a Terminal
	Server</title>

      <para>Rather than waiting until connected and typing
	<command>CONNECT <replaceable>host</replaceable></command>
	each time, use <command>tip</command>'s <literal>cm</literal>
	capability.  For example, these entries in
	<filename>/etc/remote</filename> will let you type
	<command>tip pain</command> or <command>tip muffin</command>
	to connect to the hosts <systemitem>pain</systemitem> or
	<systemitem>muffin</systemitem>, and <command>tip
	  deep13</command> to connect to the terminal server.</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

    </sect2>

    <sect2 xml:id="tip-multiline">
      <title>Using More Than One Line with
	<command>tip</command></title>

      <para>This is often a problem where a university has several
	modem lines and several thousand students trying to use
	them.</para>

      <para>Make an entry in <filename>/etc/remote</filename> and use
	<literal>@</literal> for the <literal>pn</literal>
	capability:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Then, list the phone numbers in
	<filename>/etc/phones</filename>:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> will try each number in the listed
	order, then give up.  To keep retrying, run
	<command>tip</command> in a <literal>while</literal>
	loop.</para>
    </sect2>

    <sect2 xml:id="multi-controlp">
      <title>Using the Force Character</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo> is the default <quote>force</quote> character,
	used to tell <command>tip</command> that the next character is
	literal data.  The force character can be set to any other
	character with the <command>~s</command> escape, which means
	<quote>set a variable.</quote></para>

      <para>Type
	<command>~sforce=<replaceable>single-char</replaceable></command>
	followed by a newline.  <replaceable>single-char</replaceable>
	is any single character.  If
	<replaceable>single-char</replaceable> is left out, then the
	force character is the null character, which is accessed by
	typing
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	or <keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Space</keycap>
	</keycombo>.  A pretty good value for
	<replaceable>single-char</replaceable> is
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, which is only used on some terminal
	servers.</para>

      <para>To change the force character, specify the following in
	<filename>~/.tiprc</filename>:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 xml:id="uppercase">
      <title>Upper Case Characters</title>

      <para>This happens when
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo> is pressed, which is <command>tip</command>'s
	<quote>raise character</quote>, specially designed for people
	with broken caps-lock keys.  Use <command>~s</command> to set
	<literal>raisechar</literal> to something reasonable.  It can
	be set to be the same as the force character, if neither
	feature is used.</para>

      <para>Here is a sample <filename>~/.tiprc</filename> for
	<application>Emacs</application> users who need to type
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>2</keycap>
	</keycombo> and <keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>:</para>

    <programlisting>force=^^
raisechar=^^</programlisting>

      <para>The <literal>^^</literal> is
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	  </keycombo>.</para>

    </sect2>

    <sect2 xml:id="tip-filetransfer">
      <title>File Transfers with <command>tip</command></title>

      <para>When talking to another &unix;-like operating system,
	files can be sent and received using <command>~p</command>
	(put) and <command>~t</command> (take).  These commands run
	<command>cat</command> and <command>echo</command> on the
	remote system to accept and send files.  The syntax is:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>There is no error checking, so another protocol, like
	zmodem, should probably be used.</para>
    </sect2>

    <sect2 xml:id="zmodem-tip">
      <title>Using <application>zmodem</application> with
	<command>tip</command>?</title>

      <para>To receive files, start the sending program on the remote
	end.  Then, type <command>~C rz</command> to begin receiving
	them locally.</para>

      <para>To send files, start the receiving program on the remote
	end.  Then, type <command>~C sz
	<replaceable>files</replaceable></command> to send them to the
	remote system.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info>
    <title>Setting Up the Serial Console</title>

      <authorgroup>
	<author>
	<personname>
	  <firstname>Kazutaka</firstname>
	  <surname>YOKOTA</surname>
	  </personname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	<personname>
	  <firstname>Bill</firstname>
	  <surname>Paul</surname>
	  </personname>
	  <contrib>Based on a document by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>serial console</primary></indexterm>

    <para>&os; has the ability to boot a system with a dumb
      terminal on a serial port as a console.  This configuration is
      useful for system administrators who wish to install &os; on
      machines that have no keyboard or monitor attached, and
      developers who want to debug the kernel or device
      drivers.</para>

    <para>As described in <xref linkend="boot"/>, &os; employs a three
      stage bootstrap.  The first two stages are in the boot block
      code which is stored at the beginning of the &os; slice on the
      boot disk.  The boot block then loads and runs the boot loader
      as the third stage code.</para>

    <para>In order to set up booting from a serial console, the boot
      block code, the boot loader code, and the kernel need to be
      configured.</para>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>Quick Serial Console Configuration</title>

      <para>This section provides a fast overview of setting up the
	serial console.  This procedure can be used when the dumb
	terminal is connected to <filename>COM1</filename>.</para>

      <procedure>
	<title>Configuring a Serial Console on
	  <filename>COM1</filename></title>

	<step>
	  <para>Connect the serial cable to
	    <filename>COM1</filename> and the controlling
	    terminal.</para>
	</step>

	<step>
	  <para>To configure boot messages to display on the serial
	    console, issue the following command as the
	    superuser:</para>

	  <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
	</step>

	<step>
	  <para>Edit <filename>/etc/ttys</filename> and change
	    <literal>off</literal> to <literal>on</literal> and
	    <literal>dialup</literal> to <literal>vt100</literal> for
	    the <filename>ttyu0</filename> entry.  Otherwise, a
	    password will not be required to connect via the serial
	    console, resulting in a potential security hole.</para>
	</step>

	<step>
	  <para>Reboot the system to see if the changes took
	    effect.</para>
	</step>

      </procedure>

      <para>If a different configuration is required, see the next
	section for a more in-depth configuration explanation.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>In-Depth Serial Console Configuration</title>

      <para>This section provides a more detailed explanation of the
	steps needed to setup a serial console in &os;.</para>

      <procedure>
	<title>Configuring a Serial Console</title>

	<step>
	  <para>Prepare a serial cable.</para>

	  <indexterm><primary>null-modem cable</primary></indexterm>

	  <para>Use either a null-modem cable or a standard serial
	    cable and a null-modem adapter.  See <xref
	      linkend="term-cables-null"/> for a discussion on serial
	    cables.</para>
	</step>

	<step>
	  <para>Unplug the keyboard.</para>

	  <para>Many systems probe for the keyboard during the
	    Power-On Self-Test (<acronym>POST</acronym>) and will
	    generate an error if the keyboard is not detected.  Some
	    machines will refuse to boot until the keyboard is plugged
	    in.</para>

	  <para>If the computer complains about the error, but boots
	    anyway, no further configuration is needed.</para>

	  <para>If the computer refuses to boot without a keyboard
	    attached, configure the <acronym>BIOS</acronym> so that it
	    ignores this error.  Consult the motherboard's manual for
	    details on how to do this.</para>

	  <tip>
	    <para>Try setting the keyboard to <quote>Not
		installed</quote> in the <acronym>BIOS</acronym>.
	      This setting tells the <acronym>BIOS</acronym> not to
	      probe for a keyboard at power-on so it should not
	      complain if the keyboard is absent.  If that option is
	      not present in the <acronym>BIOS</acronym>, look for an
	      <quote>Halt on Error</quote> option instead.  Setting
	      this to <quote>All but Keyboard</quote> or to <quote>No
		Errors</quote> will have the same effect.</para>
	  </tip>

	  <para>If the system has a &ps2; mouse, unplug it as well.
	    &ps2; mice share some hardware with the keyboard and
	    leaving the mouse plugged in can fool the keyboard probe
	    into thinking the keyboard is still there.</para>

	  <note>
	    <para>While most systems will boot without a keyboard,
	      quite a few will not boot without a graphics adapter.
	      Some systems can be configured to  boot with no graphics
	      adapter by changing the <quote>graphics adapter</quote>
	      setting in the <acronym>BIOS</acronym> configuration to
	      <quote>Not installed</quote>.  Other systems do not
	      support this option and will refuse to boot if there is
	      no display hardware in the system.  With these machines,
	      leave some kind of graphics card plugged in, even if it
	      is just a junky mono board.  A monitor does not need to
	      be attached.</para>
	  </note>
	</step>

	<step>
	  <para>Plug a dumb terminal, an old computer with a modem
	    program, or the serial port on another &unix; box into the
	    serial port.</para>
	</step>

	<step>
	  <para>Add the appropriate <literal>hint.sio.*</literal>
	    entries to <filename>/boot/device.hints</filename> for the
	    serial port.  Some multi-port cards also require kernel
	    configuration options.  Refer to &man.sio.4; for the
	    required options and device hints for each supported
	    serial port.</para>
	</step>

	<step>
	  <para>Create <filename>boot.config</filename> in the root
	    directory of the <literal>a</literal> partition on the
	    boot drive.</para>

	  <para>This file instructs the boot block code how to boot
	    the system.  In order to activate the serial console, one
	    or more of the following options are needed.  When using
	    multiple options, include them all on the same
	    line:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>Toggles between the internal and serial
		  consoles.  Use this to switch console devices.  For
		  instance, to boot from the internal (video) console,
		  use <option>-h</option> to direct the boot loader
		  and the kernel to use the serial port as its console
		  device.  Alternatively, to boot from the serial
		  port, use <option>-h</option> to tell the boot
		  loader and the kernel to use the video display as
		  the console instead.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>Toggles between the single and dual console
		  configurations.  In the single configuration, the
		  console will be either the internal console (video
		  display) or the serial port, depending on the state
		  of <option>-h</option>.  In the dual console
		  configuration, both the video display  and the
		  serial port will become the console at the same
		  time, regardless of the state of
		  <option>-h</option>.  However, the dual console
		  configuration takes effect only while the boot
		  block is running.  Once the boot loader gets
		  control, the console specified by
		  <option>-h</option> becomes the only
		  console.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Makes the boot block probe the keyboard.  If no
		  keyboard is found, the <option>-D</option> and
		  <option>-h</option> options are automatically
		  set.</para>

		<note>
		  <para>Due to space constraints in the current
		    version of the boot blocks, <option>-P</option> is
		    capable of detecting extended keyboards only.
		    Keyboards with less than 101 keys and without F11
		    and F12 keys may not be detected.  Keyboards on
		    some laptops may not be properly found because of
		    this limitation.  If this is the case, do not use
		    <option>-P</option>.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Use either <option>-P</option> to select the console
	    automatically or <option>-h</option> to activate the
	    serial console.  Refer to &man.boot.8; and
	    &man.boot.config.5; for more details.</para>

	  <para>The options, except for <option>-P</option>, are
	    passed to the boot loader.  The boot loader will
	    determine whether the internal video or the serial port
	    should become the console by examining the state of
	    <option>-h</option>.  This means that if
	    <option>-D</option> is specified but <option>-h</option>
	    is not specified in <filename>/boot.config</filename>, the
	    serial port can be used as the console only during the
	    boot block as the boot loader will use the internal video
	    display as the console.</para>
	</step>

	<step>
	  <para>Boot the machine.</para>

	  <para>When &os; starts, the boot blocks echo the contents of
	    <filename>/boot.config</filename> to the console.  For
	    example:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>The second line appears only if <option>-P</option> is
	    in <filename>/boot.config</filename> and indicates the
	    presence or absence of the keyboard.  These messages go
	    to either the serial or internal console, or both,
	    depending on the option in
	    <filename>/boot.config</filename>:</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Options</entry>
		  <entry align="left">Message goes to</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>none</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>serial console</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard present</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard absent</entry>
		  <entry>serial console</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>After the message, there will be a small pause before
	    the boot blocks continue loading the boot loader and
	    before any further messages are printed to the console.
	    Under normal circumstances, there is no need to interrupt
	    the boot blocks, but one can do so in order to make sure
	    things are set up correctly.</para>

	  <para>Press any key, other than <keycap>Enter</keycap>, at
	    the console to interrupt the boot process.  The boot
	    blocks will then prompt for further action:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Verify that the above message appears on either the
	    serial or internal console, or both, according to the
	    options in <filename>/boot.config</filename>.  If the
	    message appears in the correct console, press
	    <keycap>Enter</keycap> to continue the boot
	    process.</para>

	  <para>If there is no prompt on the serial terminal,
	    something is wrong with the settings.  Enter
	    <option>-h</option> then <keycap>Enter</keycap> or
	    <keycap>Return</keycap> to tell the boot block (and then
	    the boot loader and the kernel) to choose the serial port
	    for the console.  Once the system is up, go back and check
	    what went wrong.</para>
	</step>
      </procedure>

      <para>During the third stage of the boot process, one can still
	switch between the internal console and the serial console by
	setting appropriate environment variables in the boot loader.
	See &man.loader.8; for more
	information.</para>

      <note>
	<para>This line in <filename>/boot/loader.conf</filename> or
	  <filename>/boot/loader.conf.local</filename> configures the
	  boot loader and the kernel to send their boot messages to
	  the serial console, regardless of the options in
	  <filename>/boot.config</filename>:</para>

	<programlisting>console="comconsole"</programlisting>

	<para>That line should be the first line of
	  <filename>/boot/loader.conf</filename> so that boot messages
	  are displayed on the serial console as early as
	  possible.</para>

	<para>If that line does not exist, or if it is set to
	  <literal>console="vidconsole"</literal>, the boot loader and
	  the kernel will use whichever console is indicated by
	  <option>-h</option> in the boot block.  See
	  &man.loader.conf.5; for more information.</para>

	<para>At the moment, the boot loader has no option
	  equivalent to <option>-P</option> in the boot block, and
	  there is no provision to automatically select the internal
	  console and the serial console based on the presence of the
	  keyboard.</para>
      </note>

      <tip>
	<para>While it is not required, it is possible to provide a
	  <command>login</command> prompt over the serial line.  To
	  configure this, edit the entry for the serial port in
	  <filename>/etc/ttys</filename> using the instructions in
	  <xref linkend="term-config"/>.  If the speed of the serial
	  port has been changed, change <literal>std.9600</literal> to
	  match the new setting.</para>
      </tip>
    </sect2>

    <sect2>
      <title>設定較快的序列阜速度</title>

      <para>預設下，序列阜速度是 9600 baud， 8
	bits, no parity, and 1 stop bit.  為了改變預設的 console 速度，使用下面其中一個選項:</para>

      <itemizedlist>
	<listitem>
	  <para>Edit <filename>/etc/make.conf</filename> and set
	    <varname>BOOT_COMCONSOLE_SPEED</varname> to the new
	    console speed.  Then, recompile and install the boot
	    blocks and the boot loader:</para>

	  <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>

	  <para>If the serial console is configured in some other way
	    than by booting with <option>-h</option>, or if the serial
	    console used by the kernel is different from the one used
	    by the boot blocks, add the following option, with the
	    desired speed, to a custom kernel configuration file and
	    compile a new kernel:</para>

	  <programlisting>options CONSPEED=<replaceable>19200</replaceable></programlisting>
	</listitem>

	<listitem>
	  <para>Add the <option>-S
	      <replaceable>19200</replaceable></option> boot option to
	    <filename>/boot.config</filename>, replacing
	    <replaceable>19200</replaceable> with the speed to
	    use.</para>
	</listitem>

	<listitem>
	  <para>加入下列選項到
	    <filename>/boot/loader.conf</filename>.  Replace
	    <replaceable>115200</replaceable> with the speed to
	    use.</para>

	  <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="<replaceable>115200</replaceable>"
console="comconsole,vidconsole"</programlisting>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="serialconsole-ddb">
      <title>Entering the DDB Debugger from the Serial Line</title>

      <para>為了設定核心支援從序列 console 跳入核心偵錯器的能力，在客製化核心設定檔加入下列選項並且利用
	  在 <xref linkend="kernelconfig"/> 的指令編譯核心。注意，當這是一個對於遠端偵測的有用工具時，假如有人偽造假的 BREAK 並送到序列阜，
	  它將變的很危險。想要知道更多關於核心偵錯器請參考 &man.ddb.4; and &man.ddb.8;。
	</para>

      <programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
    </sect2>
  </sect1>
</chapter>
