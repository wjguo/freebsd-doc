<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <title>串列通訊</title>

  <sect1 xml:id="serial-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>serial communications</primary></indexterm>
    <para>
	從最早期以串列線作為使用者輸入輸出的 &unix; 機器開始，&unix; 一直都支援串列通訊，當時一般的終端機，如每秒 10 個字元的印表機和鍵盤，到現在已經改變很多。本章涵蓋一些可以用在 &os; 的串列通訊的方法。</para>

    <para>讀完本章，你將知道</para>

    <itemizedlist>
      <listitem>
	<para>如何透過終端機連線到 &os; 系統。</para>
      </listitem>
      <listitem>
	<para>如何利用 modem 撥號到遠端主機。</para>
      </listitem>
      <listitem>
	<para>如何允許遠端的使用者透過 modem 登入 &os; 系統</para>
      </listitem>
      <listitem>
	<para>如何從 serial console 將 &os; 開機。</para>
      </listitem>
    </itemizedlist>

    <para>在讀本章之前，你應該:</para>

    <itemizedlist>
      <listitem>
	<para>知道如何 <link linkend="kernelconfig"> 設定和安裝一個客制化的核心</link>。</para>
      </listitem>
      <listitem>
	<para>瞭解<link linkend="basics"> &os; 權限和程序</link>.</para>
      </listitem>
      <listitem>
	<para>Have access to the technical manual for the serial
	  hardware to be used with &os;.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>串列術語與硬體</title>

    <para>下列是常用的串列通訊專有名詞:</para>
    <variablelist>
      <varlistentry>
	<term><acronym>bps</acronym></term>
	<listitem>
	  <para>Bits per
	    Second<indexterm><primary>bits-per-second</primary></indexterm>
	    (<acronym>bps</acronym>) 是每秒資料傳輸速率</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>DTE</acronym></term>
	<listitem>
	  <para>Data Terminal
	    Equipment<indexterm><primary>DTE</primary></indexterm>
	    (<acronym>DTE</acronym>) 是串列通訊中的兩端點之一，例如電腦。
	    </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>DCE</acronym></term>
	<listitem>
	  <para>Data Communications
	    Equipment<indexterm><primary>DCE</primary></indexterm>
	    (<acronym>DTE</acronym>) 是串列通訊的另一個端點，基本上，它可能是一個 modem 或串列終端。
	    </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>RS-232</acronym></term>
	<listitem>
	  <para>原本定義硬體串列通訊的標準，它已經被重新命名為
	    <acronym>TIA-232</acronym>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>當提及通訊資料速率，本節將不使用<firstterm>鮑</firstterm>。鮑是指一段時間電子狀態轉換的次數；實際上，而 <acronym>bps</acronym> 才是通訊資料速率的正確用詞。</para>

    <para>為了透過串列終端機連到 &os; 系統，電腦必須要有一個串列阜和適當的串列線，對於串列硬體和接線方式很熟的讀者，可以放心地略過本節。</para>

    <sect2 xml:id="term-cables-null">
      <title>串列纜線和串列阜</title>

      <para>串列覽線有許多不同的類型，兩種最常見的是 null-modem 纜線和標準 
	<acronym>RS-232</acronym> 纜線。你的串列硬體文件應該會描述需要哪一種類型的纜線。</para>

      <para>這兩種類型的線差別在於內部的線如何到連接頭，每一條線表示一個預先定義的訊號，整理在
	<xref linkend="serialcomms-signal-names"/>。一個標準的串列纜線直接傳送全部<acronym>RS-232C</acronym> 訊號。例如，纜線其中一端的<quote>Transmitted
	  Data</quote> 連到另一端的<quote>Transmitted Data</quote>。 這是用連接 modem 到 &os; 系統的纜線類型，對於某些終端也是最適合的
	</para>

      <para>一個 null-modem 纜線轉換成成連接頭一端的<quote>Transmitted
	  Data</quote> 連接到另一端的<quote>Received Data</quote>。連接頭可以是<acronym>DB-25</acronym>，不然就是<acronym>DB-9</acronym>。
	  <para>

      <para>null-modem 纜線可以使用<xref linkend="nullmodem-db25"/>,
	  <xref linkend="nullmodem-db9"/>和<xref
	  linkend="nullmodem-db9-25"/>的腳位對應來製作。當標準規定腳位 1 直接對接，<quote>Protective
	  Ground</quote> 線時常被省略。在一些不同的設定下，有一些終端只有使用到腳位 2、3、7。nals
	  如果有疑惑，請參考串列硬體的文件。
	  </para>

      <indexterm>
	<primary>null-modem cable</primary>
      </indexterm>

      <table frame="none" pgwide="1"
	xml:id="serialcomms-signal-names">
	<title><acronym>RS-232C</acronym> Signal Names</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry align="left">Acronyms</entry>
	      <entry align="left">Names</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><acronym>RD</acronym></entry>
	      <entry>Received Data</entry>
	    </row>

	    <row>
	      <entry><acronym>TD</acronym></entry>
	      <entry>Transmitted Data</entry>
	    </row>

	    <row>
	      <entry><acronym>DTR</acronym></entry>
	      <entry>Data Terminal Ready</entry>
	    </row>

	    <row>
	      <entry><acronym>DSR</acronym></entry>
	      <entry>Data Set Ready</entry>
	    </row>

	    <row>
	      <entry><acronym>DCD</acronym></entry>
	      <entry>Data Carrier Detect</entry>
	    </row>

	    <row>
	      <entry><acronym>SG</acronym></entry>
	      <entry>Signal Ground</entry>
	    </row>

	    <row>
	      <entry><acronym>RTS</acronym></entry>
	      <entry>Request to Send</entry>
	    </row>

	    <row>
	      <entry><acronym>CTS</acronym></entry>
	      <entry>Clear to Send</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db25">
	<title>DB-25 to DB-25 Null-Modem 纜線</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>SG</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>RD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>RTS</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>20</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>20</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db9">
	<title>DB-9 to DB-9 Null-Modem Cable</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>RD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>1</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>SG</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>1</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>RTS</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="none" pgwide="1" xml:id="nullmodem-db9-25">
	<title>DB-9 to DB-25 Null-Modem Cable</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry align="left">Signal</entry>
	      <entry align="left">Pin #</entry>
	      <entry></entry>
	      <entry align="left">Pin #</entry>
	      <entry align="left">Signal</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>RD</entry>
	      <entry>2</entry>
	      <entry>connects to</entry>
	      <entry>2</entry>
	      <entry>TD</entry>
	    </row>

	    <row>
	      <entry>TD</entry>
	      <entry>3</entry>
	      <entry>connects to</entry>
	      <entry>3</entry>
	      <entry>RD</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>6</entry>
	      <entry>DSR</entry>
	    </row>

	    <row>
	      <entry>DTR</entry>
	      <entry>4</entry>
	      <entry>connects to</entry>
	      <entry>8</entry>
	      <entry>DCD</entry>
	    </row>

	    <row>
	      <entry>SG</entry>
	      <entry>5</entry>
	      <entry>connects to</entry>
	      <entry>7</entry>
	      <entry>SG</entry>
	    </row>

	    <row>
	      <entry>DSR</entry>
	      <entry>6</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>DCD</entry>
	      <entry>1</entry>
	      <entry>connects to</entry>
	      <entry>20</entry>
	      <entry>DTR</entry>
	    </row>

	    <row>
	      <entry>RTS</entry>
	      <entry>7</entry>
	      <entry>connects to</entry>
	      <entry>5</entry>
	      <entry>CTS</entry>
	    </row>

	    <row>
	      <entry>CTS</entry>
	      <entry>8</entry>
	      <entry>connects to</entry>
	      <entry>4</entry>
	      <entry>RTS</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <note>
	<para>當一個接頭的腳位連接到另一接頭上配對的腳位，它通常是用短線連接起來；長線用來連接到其他單一腳位。
	</para>
      </note>

      <para>串列阜是資料在 &os; 主機電腦和終端傳輸經過的設備。存在好幾種串列阜，在購買或打造一條纜線之前，確定它能適合終端和&os;系統上的串列阜。
	</para>

      <para>大部分的終端提供<acronym>DB-25</acronym>串列阜。
	個人電腦可能提供<acronym>DB-25</acronym>或
	<acronym>DB-9</acronym>串列阜。一個多阜的串列卡可能提供
	<acronym>RJ-12</acronym>或<acronym>RJ-45/</acronym>
	串列阜。請見該串列阜硬體隨附的文件，或者肉眼辨識串列阜的類別。</para>

      <para>在 &os;，每一個串列阜需透過在
	 <filename>/dev</filename>下的節點去存取。有兩種不同的節點:
	  </para>

      <itemizedlist>
	<listitem>
	  <para>Call-in ports 命名為
	    <filename>/dev/ttyu<replaceable>N</replaceable></filename>
	    ，而<replaceable>N</replaceable> 是阜的號碼，從零開始。
	    如果終端連接到第一個串列阜 (<filename>COM1</filename>)，使用
	    <filename>/dev/ttyu0</filename>與該終端通訊。
	    如果終端正在第二個串列阜上 (<filename>COM2</filename>)，則使用
	    <filename>/dev/ttyu1</filename>，以此類推。一般來說，
	    call-in 阜　被用在終端。為了正常運作，Call-in 阜要求串列線具備<quote>Data　Carrier Detect</quote> 訊號。
		</para>
	</listitem>

	<listitem>
	  <para>Call-out 阜命名為
	    <filename>/dev/cuau<replaceable>N</replaceable></filename>
	    on &os; versions 10.x and higher and
	    <filename>/dev/cuad<replaceable>N</replaceable></filename>
	    on &os; versions 9.x and lower.  Call-out 阜通常不用在終端，而是用在 modem。Call-out 阜可以被用在當串列線或者終端不支援<quote>Data Carrier Detect</quote>訊號。
	  </para>
	</listitem>
      </itemizedlist>

      <para>&os; 也提供初始化裝置
	(<filename>/dev/ttyu<replaceable>N</replaceable>.init</filename>
	和
	<filename>/dev/cuau<replaceable>N</replaceable>.init</filename>
	或
	<filename>/dev/cuad<replaceable>N</replaceable>.init</filename>)
	和鎖定裝置
	(<filename>/dev/ttyu<replaceable>N</replaceable>.lock</filename>
	和
	<filename>/dev/cuau<replaceable>N</replaceable>.lock</filename>
	或
	<filename>/dev/cuad<replaceable>N</replaceable>.lock</filename>).
	初始化裝置用來初始化通訊阜開啟的的參數，例如用 <literal>RTS/CTS</literal> 訊號來做 modem 流量控制的 <literal>crtscts</literal>。
	鎖定裝置提供鎖定旗標，防止使用者或程式改變某種參數。想瞭解更多終端設定、鎖定和初始化裝置、設定終端選項的資訊，
	請分別參考 &man.termios.4;, &man.sio.4;, and &man.stty.1;，
	</para>
    </sect2>

    <sect2 xml:id="serial-hw-config">
      <title>串列阜設定</title>

      <para>預設下，&os; 支援四種已知的串列阜<filename>COM1</filename>、
	<filename>COM2</filename>、<filename>COM3</filename>、
	<filename>COM4</filename>。  &os; 也支援 dumb multi-port
	串列介面卡，例如：　BocaBoard 1008 and 2016，還有 Digiboard 製造的智慧多阜卡。然而，預設核心只會搜尋標準<filename>COM</filename>阜。
	 </para>

 	<para>  
	為了看出系統是不是可辨識出串列阜，搜尋系統開機訊息中與
	<literal>uart</literal>有關的部份:</para>

      <screen>&prompt.root; <userinput>grep uart /var/run/dmesg.boot</userinput></screen>

      <para>如果系統沒有辨識出所有的串列阜，可以將額外項目加入 <filename>/boot/device.hints</filename>，
	  這個檔案已經包含了一些項目， <literal>hint.uart.0.*</literal> 相關項目為了 <filename>COM1</filename>，
	  <literal>hint.uart.1.*</literal> 是為了 <filename>COM2</filename>。當新增的<filename>COM3</filename> 項目使用 <literal>0x3E8</literal>，
	  新增的 <filename>COM4</filename> 使用 <literal>0x2E8</literal>。通用 <acronym>IRQ</acronym> 的位址，<filename>COM3</filename> 是 <literal>5</literal>，
	  <filename>COM4</filename> 是 <literal>9</literal>。
	  </para>

      <indexterm><primary><filename>ttyu</filename></primary></indexterm>
      <indexterm><primary><filename>cuau</filename></primary></indexterm>

      <para>為了決定 Port 使用的預設終端<filename>COM2</filename>設定，指定它的設備名字。下面的範例決定在 <filename>COM2</filename> 上的 call-in port 設定:
	  </para>
      <screen>&prompt.root; <userinput>stty -a -f /dev/<replaceable>ttyu1</replaceable></userinput></screen>

      <para>系統層級的串列設備初始化被<filename>/etc/rc.d/serial</filename>控制。這個檔案影響串列裝置的預設設定。為了改變一個裝置的設定， 
	  可以利用 <command>stty</command>。預設下，設定改變的影響只有在裝置關閉前有效，當裝置被重新開啟，設定將回到預設值。
	  為了永久地改變預設設定，開啟並且調整 init 裝置的設定。例如，開啟<filename>ttyu5</filename>的<option>CLOCAL</option>模式、8 bit通訊、<option>XON/XOFF</option>流量控制，輸入:
	  </para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

      <indexterm>
	<primary>rc files</primary>
	<secondary><filename>rc.serial</filename></secondary>
      </indexterm>

      <para>為了防止應用程式試圖想改變設定，可以對 locking 裝置調整。
		例如，為了將<filename>ttyu5</filename>固定在57600&nbsp;bps，輸入：
	  </para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.lock 57600</userinput></screen>

      <para>從今以後，任何想要開啟並改變<filename>ttyu5</filename>速率的程式，將一直停在 57600&nbsp;bps。
	  </para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info>
    <title>Terminals</title>

      <authorgroup>
	<author>
	<personname>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	</personname>
	  <contrib>Contributed by </contrib>
    <!--in July 1996 -->
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>terminals</primary></indexterm>

    <para>當不在電腦前或已連線的電腦網路情況下，終端提供一個方便而且低花費的方法去存取&os;系統，本節描述如何使用終端與&os;互動
	</para>

    <para>最初的 &unix; 並沒有 console。反而，使用者透過連到電腦串列阜的終端登入並執行程式
	</para>

    <para>至今幾乎每一個&unix;-like作業系統仍保留透過串列阜建立一個登入連線的能力，包括&os;，
	透過附屬在閒置的串列阜終端，使用者可以登入，並且執行跟在 console 或者一個 <command>xterm</command>視窗一模一樣的文字程式，
    </para>

    <para>許多終端可以被連結到&os;系統。一個叫老的備用電腦可以被當成一個終端，連接到能力比較強的 &os;，這將使單人電腦變成多人電腦。
    </para>

    <para>&os; 支援三種型態的終端:</para>

    <variablelist>
      <varlistentry>
	<term>Dumb terminals</term>
	<listitem>
	  <para>Dumb terminals 是一種透過串列線連到電腦的專門硬體，他們被稱為 <quote>dumb</quote>，是因為他們只有足夠用的計算能力來顯示和傳送文字，
	  不能在裝置上面執行任何程式，反而是 dumb terminals 所連到的電腦執行所需的程式。
	  </para>

	  <para>有上千種各種製造商的簡易終端，其中大部分可以與 &os; 正常互動。有些高階的終端甚至可以顯示圖形，但是只有某些軟體套件可以使用到這些進階功能。
		</para>

	  <para>Dumb terminals 在一些不需要圖形應用程式的工作環境非常熱門功能。
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Computers Acting as Terminals</term>
	<listitem>
	  <para>從簡易終端有剛剛好足夠的能力在顯示、傳送和接收文字，任何閒置的電腦可以成為一個簡易終端，只需要一條適當地纜線與在電腦上執行<firstterm>終端模擬</firstterm>軟體</para>

	  <para>這個設定檔將非常有用，例如，如果有一個使用者在忙於&os;系統的 console，同時，其他使用者可以透過效能中等的電腦透過終端到 &os; 系統做文字處理，
		</para>
	  <para>
	  在 base 系統至少有兩個通用工具可以用進行串列連線:
	    &man.cu.1; 和 &man.tip.1;。</para>

	  <para>例如，為了從 &os; 客戶端系統透過串列連到其他系統:
	  </para>

	  <screen>&prompt.root; <userinput>cu -l <replaceable>serial-port-device</replaceable></userinput></screen>

	  <para>將 <replaceable>serial-port-device</replaceable>替換成連接的串列阜裝置名稱，
	  在些裝置在 &os; versions 10.x 以上叫 <filename>/dev/cuau<replaceable>N</replaceable></filename>，
		在 &os; versions 9.x 以下叫<filename>/dev/cuad<replaceable>N</replaceable></filename>。
	   在任何一種情況，<replaceable>N</replaceable>是串列阜號碼，從零開始。
	   這意味著在 &os; <filename>COM1</filename> 對應到<filename>/dev/cuau0</filename>或<filename>/dev/cuad0</filename>。
		</para>

	  <para>額外的應用程式可以透過 Ports Collection 取得，例如
	    <package>comms/minicom</package>。</para>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>X Terminals</term>
	<listitem>
	  <para>X terminals 是可取得終端中較複雜的。不像連接到串列阜，它們通常連接到網路，例如 Ethernet。不僅僅能顯示文字型的應用程式，
	  他們還可以顯示任何 <application>&xorg;</application> 的應用程式。
	</para>

	  <para>本章不包涵 X 終端的建立、設定與使用。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2 xml:id="term-config">
      <title>Terminal Configuration</title>

      <para>本節描述如何設定在 &os; 系統啟用串列終端的登入連線。它解設系統認得終端連結的串列阜並且終端與正確的纜線連接。
	</para>

      <para>在 &os;， <command>init</command> 讀取
	<filename>/etc/ttys</filename> 並且在可用的終端執行
	<command>getty</command> 程序。<command>getty</command> 程序是負責讀取登入名稱並執行 <command>login</command> 程式。
	&os; 系統允許的 Ports 列在<filename>/etc/ttys</filename>。例如，第一個虛擬 console，<filename>ttyv0</filename>，
	有一個項目在這個檔案，允許在這個 console 登入。
	這個檔案也包含其他虛擬 console、序列阜、pseudo-ttys。以硬體終端而言，串列阜的<filename>/dev</filename>項目被列在檔案中，但名字不包含 <literal>/dev</literal> 部份。
	例如，<filename>/dev/ttyv0</filename>被列為<literal>ttyv0</literal>。
	</para>

      <para>預設 <filename>/etc/ttys</filename> 設定前四個串列阜的支援，<filename>ttyu0</filename>到<filename>ttyu3</filename>:
	</para>

      <programlisting>ttyu0   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu1   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu2   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu3   "/usr/libexec/getty std.9600"   dialup  off secure</programlisting>

      <para>當連接一個終端到其中一個阜，修改預設的項目去設定所需的速度和終端型態，將裝置設定為 <literal>on</literal> 來啟用，如果有必要，
	  改變阜的<literal>secure</literal>設定。如果終端被連接到其他阜，替那個阜增加一筆項目。
	</para>

      <para><xref linkend="ex-etc-ttys"/> 設定兩個終端在
	<filename>/etc/ttys</filename>.  第一筆項目設定一個連接到 <filename>COM2</filename> 的 Wyse-50。第二筆項目設定一個使用<application>Procomm</application>終端軟體模擬
	 VT-100 老電腦的終端。這個電腦被連接到一個多串列阜卡的第五個阜。
	  </para>

      <example xml:id="ex-etc-ttys">
	<title>Configuring Terminal Entries</title>

	<programlisting>ttyu1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure</programlisting>

	<calloutlist>
	  <callout arearefs="co-ttys-line1col1">
	    <para>第一個欄位指定串列終端的裝置名稱。</para>
	  </callout>

	  <callout arearefs="co-ttys-line1col2">
	    <para>第二個欄位用來告訴<command>getty</command>去初始化，開啟裝置，設定裝置速度，提示使用者給予一個使用者名稱，並且執行<command>login</command>程式。
		額外選項<firstterm>getty type</firstterm>設定終端線的特性，如<acronym>bps</acronym>速率和 parity。可用的 getty 型態被列在<filename>/etc/gettytab</filename>。
	      在大部分情況下，以<literal>std</literal> 開頭的 getty 型態名稱將作為硬體終端使用，這些項目忽略 parity，有一個
		  <literal>std</literal> 項目作為代表每一個從 100 到 115200 的 <acronym>bps</acronym>速率。更多訊息可參考&man.gettytab.5;。

	    <para>當設定一個 getty 的型態，確保符合終端使用的通訊設定。例如，Wyse-50 使用 no parity　和運作在38400&nbsp;bps　下。
		而那台老舊的電腦使用 no parity 並且運作在 19200&nbsp;bps 下。
	     </para>
	  </callout>

	  <callout arearefs="co-ttys-line1col3">
	  	<para>
		 <literal>撥號</literal> 
	    第三個欄位是終端的型態。作為撥號阜，從使用者實際上可能用任何型態的終端或軟體來撥號開始，這個欄位通常是使用 <literal>unknown</literal> or 
		<literal>dialup</literal>。這個終端型態並不會改變硬體終端，在 <filename>/etc/termcap</filename> 真正的終端型態是可以被指定，例如，
		Wyse-50　使用真正的終端型態，然而，執行 <application>Procomm</application> 被設定去模擬 VT-100。
	    </para>
	  </callout>

	  <callout arearefs="co-ttys-line1col4">
	    <para>第四個欄位說明使否這個阜是啟用的
		為了啟用這個阜支援使用者登入，這個欄位必須被設成 <literal>on</literal>。
	    </para>
	  </callout>

	  <callout arearefs="co-ttys-line1col5">
	    <para>
		最後一個欄位是指定是否安全，用 <literal>secure</literal> 標記這個阜是表示
		它是可被信任，允許 <systemitemclass="username">root</systemitem> 從那個阜登入。
		不安全的阜不允許 <systemitemclass="username">root</systemitem> 登入。
		在一個不安全的阜上，使用者必須從一般帳號登入，然後利用 <command>su</command> 或類似的機制來獲得超級使用者的權限，
		如同 <xref linkend="users-superuser"/> 所描述的。為了許多安全上的考量，
		建議將設定改成 <literal>insecure</literal>。
	    </para>
	  </callout>
	</calloutlist>
      </example>

      <para>對<filename>/etc/ttys</filename> 做任何改變之後, 送一個 SIGHUP (hangup) 訊號給 <command>init</command> 程序，強制它重新讀取他的設定檔:
	</para>

      <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

      <para>自從 <command>init</command> 是第一個系統執行的程式開始，它的程序 <acronym>ID</acronym> 一直為 <literal>1</literal>。</para>

      <para>如果每一件事情都有正確設定，纜線都有接好，每一個終端機都有上電，一個 <command>getty</command> 程序現在應該已經在每一個終端執行，而且登入提示應該出現在每一個終端前。
	</para>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>疑難排解連線問題</title>

      <para>即使小心翼翼的注意每一個細節，設定終端時總是有可能某些東西出錯，
	  這裡提供一個清單，列出常見的症狀跟建議的解決方法。
	  </para>

      <para>如果沒有登入提示出現，確定終端機是有被接上並且上電。如果它是一個個人電腦當成終端機，確定終端模擬軟體有開啟正確的序列阜。
	</para>

      <para>確定纜線有被牢固的接在終端機和 &os; 電腦之間。確定纜線的種類是正確的。
	</para>

      <para>確定終端機和 &os; 可以適合 <acronym>bps</acronym> 速率和 parity 設定。以視訊撥放的終端機，確定對比跟亮度控制是 turn up。如果是一個列印終端，確保紙張跟墨水有正確放置。
	</para>

      <para>使用 <command>ps</command> 來確保
	<command>getty</command> 程序正在執行中並且提供終端服務。舉例來說，下列顯示有ㄧ個
	<command>getty</command> 正在使用第二個序列埠
	<filename>ttyu1</filename>，並且使用在<filename>/etc/gettytab</filename>內的<literal>std.38400</literal>項目:
	</para>

      <screen>&prompt.root; <userinput>ps -axww|grep ttyu</userinput>
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

      <para>如果沒有任何 <command>getty</command> 程序正在執行，確保該序列埠在 <filename>/etc/ttys</filename> 有被啟用。
	  修改完 <filename>/etc/ttys</filename> 記得執行 <command>kill -HUP 1</command> 
	  </para>

      <para>如果 <command>getty</command> 程序正在執行但是終端仍然沒有顯示燈入提示
	  ，或者有顯示提示但是不能接受任何鍵盤輸入，終端機或纜線可能不支援硬體交握，
	  試試看將 <filename>/etc/ttys</filename> 的該項目從 <literal>std.38400</literal> 改成 <literal>3wire.38400</literal>，修改完 <filename>/etc/ttys</filename> 之後
	  ，執行 <command>kill -HUP 1</command>。<literal>3wire</literal> 項目跟 <literal>std</literal> 相似，但是忽略硬體交握。當使用 <literal>3wire</literal> 
	  來防止緩衝區溢位，它的 baud 率可能需要降低，或者啟用軟體流量控制。
	</para>

      <para>如果出現的是垃圾訊息而不是登入提示，確保終端機和 &os; 適合使用 <acronym>bps</acronym> 速率和 parity 設定
	檢查 <command>getty</command> 程序來確保使用的是正確的 <replaceable>getty</replaceable> 類型。如果不是，編輯
	<filename>/etc/ttys</filename> 然後執行 <command>kill -HUP 1</command>.</para>

      <para>如果出現重複字元和密碼被顯示，更換終端機或者終端模擬軟體，from <quote>half duplex</quote> or <quote>local 
	  echo</quote> to <quote>full duplex.</quote></para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info>
    <title>撥入服務</title>

      <authorgroup>
	<author>
	<personname>
	<firstname>Guy</firstname>
	  <surname>Helmer</surname>
	  </personname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	<personname>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  </personname>
	  <contrib>Additions by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>撥入服務</primary></indexterm>

    <para>設定 &os; 系統的 dial-in 服務就像設定終端機, 除了數據機是"被用"，而不是
	終端設備。 &os; 支援外部跟內部數據機。
    </para>

    <para>
	  外部數據機通常比較方便，因為通常他們可以透過放在 non-volatile <acronym>RAM</acronym>的參數來設定，
	  而且他們也提供燈號來指示重要的 <acronym>RS-232</acronym> 訊號狀態，顯示是否數據機正常運作中。
    </para>

    <para>內部數據機通常缺乏 lack non-volatile
      <acronym>RAM</acronym>，所以設定方式可能被限制
      setting <acronym>DIP</acronym> switches.  
	  如果內部數據機有任何訊號指示燈，有可能被電腦機殼蓋住而很難發現
    </para>

    <indexterm><primary>modem</primary></indexterm>

    <para>當使用外部數據機時，是需要一條正確的纜線，
      標準的<acronym>RS-232C</acronym> 串列線應該足夠
    </para>

    <para>&os; 需要 <acronym>RTS</acronym> 和
      <acronym>CTS</acronym> 訊號用來控制高於 2400&nbsp;bps 速度的流量。
	  <acronym>CD</acronym> 用來偵測當一個通話已經被答覆或者已經被掛斷。
	  <acronym>DTR</acronym> 訊號是在一個連線會話完成後，用來重置 modem。
	  一些纜線被並沒有接上所有的訊號線，如果掛斷了連線，一個登入會話並沒有離開，問題很可能出在纜線。
	  想瞭解更多關於這些訊號，請參考 <xreflinkend="term-cables-null"/>。
    </para>

    <para>
	 如其他 &unix;-like 作業系統，&os; 使用硬體訊號來發現一個通話已經被回應、掛斷，或者是在通話結束後，掛斷通話或重置 modem。
	 &os; 避免送命令到 modem 或監看 modem 送來的狀態。
    </para>

    <para>&os; 支援 <acronym>NS8250</acronym>,
      <acronym>NS16450</acronym>, <acronym>NS16550</acronym> 和
      <acronym>NS16550A</acronym>-based <acronym>RS-232C</acronym>
      (<acronym>CCITT</acronym> V.24) 通訊介面。
      8250 和 16450 設備有單一字元緩衝區。
	  16550 設備提供一個 16 字元緩衝區，這是為了得到較好的系統效能。
　　　在 16550 設備上的 16 字元緩衝區有一些瑕疵，盡可能使用 16550A 設備。
　　　因為單一字元緩衝區比16 字元緩衝區在作業系統上需要多一點功夫，建議使用 16550A 式的串列介面卡。
	　如果系統已經有許多活動中的串列阜或者負載很高，16550A 式介面卡對於低錯誤率的通訊比較好。
     </para>

    <para>這一章節剩下的部份展示如何設定 modem 來接受連入的連線、如何與 modem 通訊
	以及提供一些故障排除的提示。
    </para>

    <sect2 xml:id="dialup-ttys">
      <title>Modem 設定</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>以終端來說terminals，<command>init</command> 為每一個為撥入連線設定好的串列阜產生一個 <command>getty</command> 程序，
		當一個使用者成功撥上 modem，modem 會發出 <quote>Carrier Detect</quote> 訊號。核心將偵測到媒介，
		並命令 <command>getty</command> 打開一個阜，在指定的速率下顯示 <prompt>login:</prompt>。
		如果收到垃圾字元，通常是 model 與設定的速率不匹配，<command>getty</command> 會場是調整速率直到收到適當的字元。
		在使用者輸入他們的登入名稱後，<command>getty</command> 執行 <command>login</command> 來訊問使用者的密碼，完成登入的流程，
		然後啟動使用者的 shell。
	  </para>

      <indexterm>
	<primary><command>/usr/bin/login</command></primary>
      </indexterm>

      <para>關於撥上 modem，有兩派想法。一派是設定 modem 和系統，不管使用者用何種速率撥入，
	　撥入的 <acronym>RS-232</acronym> 將在一個固定速度下通訊。
	  這樣做的好處是遠端的使用者總是可以馬上看到系統登入的提示，不好的地方是系統不知道使用者真實的
	  資料速率，這樣將使全螢幕的應用程式，如 <application>Emacs</application> 將不能在較慢的連線時，調整螢幕顯示方法來取得較好的回應時間。
	  </para>

      <para>另一派是設定 <acronym>RS-232</acronym> 介面隨著遠端使用者的連線速度變化。
	  因為 <command>getty</command> 並不曉得任何 modem 的連線速度報告訊息，它基於初始速度送出 <prompt>login:</prompt> 然後等待回應字元。
	  如果使用者看到亂碼，他們應該壓住 <keycap>Enter</keycap> 直到看到可識別的提示。如果資料速率沒有匹配，
	  <command>getty</command> 將視使用者的任何輸入為垃圾，然後嘗試下一個速度，再次送出 <prompt>login:</prompt> 提示。
	  正常情況下，這個步驟重複一到兩次，使用者就能看到正確的訊息。這個登入的順序看起來不像固定速度方法那樣乾淨，但是一個低速連線的使用者在
	  全螢幕程式下可能得到叫好得互動回應。
	  </para>

      <para>當鎖定 modem 的資料通訊速率在一個特殊的速度，
	  不需要改 <filename>/etc/gettytab</filename>。
	  然後，為了匹配速度，可能需要額外的項目來定義使用該 modem 的速度。
	  這個範例設定了一個 14.4&nbsp;Kbps modem 與一個使用 8-bit，no parity，最高速度 19.2&nbsp;Kbps 的介面連線，
	  它設定 <command>getty</command> 來啟動 V.32通訊速率在 19.2&nbsp;Kbps，然後從 9600&nbsp;bps、2400&nbsp;bps、1200&nbsp;bps、300&nbsp;bps 
	  循環，最後回到 19.2&nbsp;Kbps。
	  速率循環定義在 <literal>nx=</literal> (next table) 屬性。每一行使用 <literal>tc=</literal> (table continuation)，
	　來補足剩下特殊的資料速率。
	  </para>

      <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

      <para>For a 28.8&nbsp;Kbps modem, or to take advantage of
	compression on a 14.4&nbsp;Kbps modem, use a higher
	communications rate, as seen in this example:</para>

      <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

      <para>慢速 <acronym>CPU</acronym> 或高負載的系統若沒有 16550A 式串列阜，這個設定在 57.6&nbsp;Kbps 
	  可能產生 <errorname>sio</errorname><quote>silo</quote> 錯誤。
	  </para>

      <indexterm>
	<primary><filename>/etc/ttys</filename></primary>
      </indexterm>

      <para>The configuration of <filename>/etc/ttys</filename> is
	similar to <xref linkend="ex-etc-ttys"/>, but a different
	argument is passed to <command>getty</command> and
	<literal>dialup</literal> is used for the terminal type.
	Replace <replaceable>xxx</replaceable> with the process
	<command>init</command> will run on the device:</para>

      <programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

      <para>The <literal>dialup</literal> terminal type can be
	changed.  For example, setting <literal>vt102</literal> as the
	default terminal type allows users to use
	<acronym>VT102</acronym> emulation on their remote
	systems.</para>

      <para>For a locked-speed configuration, specify the speed with
	a valid type listed in <filename>/etc/gettytab</filename>.
	This example is for a modem whose port speed is locked at
	19.2&nbsp;Kbps:</para>

      <programlisting>ttyu0   "/usr/libexec/getty std.<replaceable>19200</replaceable>"   dialup on</programlisting>

      <para>In a matching-speed configuration, the entry needs to
	reference the appropriate beginning <quote>auto-baud</quote>
	entry in <filename>/etc/gettytab</filename>.  To continue the
	example for a matching-speed modem that starts at
	19.2&nbsp;Kbps, use this entry:</para>

      <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>

      <para>After editing <filename>/etc/ttys</filename>, wait until
	the modem is properly configured and connected before
	signaling <command>init</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

      <indexterm>
	<primary>rc files</primary>
	<secondary><filename>rc.serial</filename></secondary>
      </indexterm>

      <para>高速數據機，例如 <acronym>V.32</acronym>,
	<acronym>V.32bis</acronym>, 和 <acronym>V.34</acronym>
	數據機，使用硬體 (<literal>RTS/CTS</literal>) 流量控制。
	可以用 <command>stty</command> 設定該阜的硬體流量控制旗標。
	這個範例設定了
	<varname>crtscts</varname> 旗標在 <filename>COM2</filename> 的
	dial-in and dial-out 初始化設備:</para>

      <screen>&prompt.root; <userinput>stty -f /dev/ttyu1.init crtscts</userinput>
&prompt.root; <userinput>stty -f /dev/cuau1.init crtscts</userinput></screen>
    </sect2>

<!--
Comment out for now. If this is still needed, the example should
either be updated or the section modified to be more generic
e.g. refer to the modem's manual
    <sect2>
      <title>Modem Settings</title>

      <para>For a modem whose parameters may be permanently set in
	non-volatile RAM, a terminal program such as
	<command>tip</command> can be used to set the parameters.
	Connect to the modem using the same communications speed as
	the initial speed <command>getty</command> will use and
	configure the modem's non-volatile RAM to match these
	requirements:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>CD</acronym> asserted when connected.</para>
	</listitem>

	<listitem>
	  <para><acronym>DTR</acronym> asserted for operation and
	    dropping DTR hangs up the line and resets the
	    modem.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> transmitted data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Disable <acronym>XON/XOFF</acronym> flow
	    control.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> received data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (no result codes).</para>
	</listitem>

	<listitem>
	  <para>No command echo.</para>
	</listitem>
      </itemizedlist>

      <para>Read the documentation for the modem to find out
	which commands and/or DIP switch settings are needed.</para>

      <para>For example, to set the above parameters on a &usrobotics;
	&sportster; 14,400 external modem, give these commands to
	the modem:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Other settings can be adjusted in the modem, such as
	whether it will use V.42bis and/or MNP5 compression.</para>

      <para>The &usrobotics; &sportster; 14,400 external modem also
	has some DIP switches that need to be set.  Other modems,
	may need these settings:</para>

      <itemizedlist>
	<listitem>
	  <para>Switch 1: UP &mdash; DTR Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 2: N/A (Verbal Result Codes/Numeric Result
	    Codes)</para>
	</listitem>

	<listitem>
	  <para>Switch 3: UP &mdash; Suppress Result Codes</para>
	</listitem>

	<listitem>
	  <para>Switch 4: DOWN &mdash; No echo, offline
	    commands</para>
	</listitem>

	<listitem>
	  <para>Switch 5: UP &mdash; Auto Answer</para>
	</listitem>

	<listitem>
	  <para>Switch 6: UP &mdash; Carrier Detect Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 7: UP &mdash; Load NVRAM Defaults</para>
	</listitem>

	<listitem>
	  <para>Switch 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>Result codes should be disabled/suppressed for dial-up
	modems to avoid problems that can occur if
	<command>getty</command> mistakenly gives a
	<prompt>login:</prompt> prompt to a modem that is in command
	mode and the modem echoes the command or returns a result
	code.  This sequence can result in an extended, silly
	conversation between <command>getty</command> and the
	modem.</para>

      <para>For a locked-speed configuration, configure the modem to
	maintain a constant modem-to-computer data rate independent
	of the communications rate.  On a &usrobotics; &sportster;
	14,400 external modem, these commands will lock the
	modem-to-computer data rate at the speed used to issue the
	commands:</para>

      <programlisting>ATZ
AT&amp;B1&amp;W</programlisting>

      <para>For a variable-speed configuration, configure the modem
	to adjust its serial port data rate to match the incoming
	call rate.  On a &usrobotics; &sportster; 14,400 external
	modem, these commands will lock the modem's error-corrected
	data rate to the speed used to issue the commands, while
	allowing the serial port rate to vary for
	non-error-corrected connections:</para>

      <programlisting>ATZ
AT&amp;B2&amp;W</programlisting>

      <para>Most high-speed modems provide commands to view the
	modem's current operating parameters in a somewhat
	human-readable fashion.  On the &usrobotics; &sportster;
	14,400 external modem, <command>ATI5</command> displays the
	settings that are stored in the non-volatile RAM.  To see the
	true operating parameters of the modem, as influenced by the
	modem's DIP switch settings, use <command>ATZ</command> and
	then <command>ATI4</command>.</para>

      <para>For a different brand of modem, check the modem's manual
	to see how to double-check the modem's configuration
	parameters.</para>
    </sect2>
    -->

    <sect2>
      <title>疑難排解</title>

      <para>這節提供一些提示，當  dial-up 數據機沒有連到 &os; 系統時，可以用來排解
	  </para>

      <para>將數據機掛上 &os;，然後開機，如果數據機有狀態燈，當 <prompt>login:</prompt> 提示出現在螢幕上時，
	  
	  看看數據機的 <acronym>DTR</acronym> 指示燈，如果是亮的，表示 &os; 應該已經啟動 <command>getty</command> 來處理通訊阜，
	  等待接收來自數據機的呼叫。
	  </para>

      <para>如果 <acronym>DTR</acronym> 指示燈並沒有亮起來
	  經過終端登入 &os; 系統，輸入 <command>ps ax</command> 來看 &os; 是否正在執行 <command>getty</command> 在對的串列阜：
	  </para>

      <screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 <replaceable>ttyu0</replaceable></screen>

      <para>如果第二欄顯示 <literal>d0</literal>，而不是
	<literal>??</literal>，而且數據機還沒收到一個呼叫，這表示
	<command>getty</command> 已經完成開機通訊阜的動作。
	這可能表示數據機有問題或設定錯誤，因為在 carrier 偵測到數據機發出的訊號前，
	<command>getty</command> 不應該能去開啟通訊阜，
	 </para>

      <para>如果沒有 <command>getty</command> 程序正在等待開啟通訊阜，再檢查一次 entry 有被正確的寫在 <filename>/etc/ttys</filename>，
	  還有，檢查 <filename>/var/log/messages</filename> 是否有任何來自 <command>init</command> 或 <command>getty</command> 的紀錄 .
	  </para>

      <para>接著，嘗試撥入系統，確定使用的是 8 bits,
	no parity, and 1 stop bit。 如果沒有出現立刻出現任何提示，
	試試看每秒按一次按 <keycap>Enter</keycap>。如果仍然沒有 <prompt>login:</prompt> 提示，試試看送一個 <command>BREAK</command>。
	當使用一個高速數據機時，鎖住介面的速度後，再撥一次試試看。
	  </para>

      <para>如果還是沒有 <prompt>login:</prompt> 提示，再檢查
	<filename>/etc/gettytab</filename> 一次，然後確認：
	  </para>

      <itemizedlist>
	<listitem>
	  <para>在 <filename>/etc/ttys</filename> 該項目中可用的初始化名稱跟 <filename>/etc/gettytab</filename> 內的可用名稱一樣。
	  </para>
	</listitem>

	<listitem>
	  <para>每個 <literal>nx=</literal> 項目符合其他在
	    <filename>gettytab</filename> 的可用名稱。</para>
	</listitem>

	<listitem>
	  <para>每個 <literal>tc=</literal> 項目符合其他
	    <filename>gettytab</filename> 的可用名稱。</para>
	</listitem>
      </itemizedlist>

      <para>如果在 &os; 系統上的 modem 沒有回應，確定當 <acronym>DTR</acronym> 生效， modem 的設定能回應電話。
	  如果 modem 看起來有正確的被設定，檢查 modem 的 <acronym>DTR</acronym> 指示燈來確定線路是否正常。
	  </para>

      <para>如果還是不能用，描述遇到的問題，寄一封電子郵件給 &a.questions;。
	  </para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialout">
    <title>Dial-out 服務</title>

    <indexterm><primary>dial-out service</primary></indexterm>

    <para>下列提示是讓主機透過 modem 連到其他電腦。這適合與遠端建立一個終端連線。
    </para>

    <para>如果 PPP 連線有問題，這種連線方式將非常有用來從網路取得檔案。
	如果 PPP 不能運作，使用這種終端連線透過 FTP 取得需要的檔案。然後使用 zmodem 來傳送它到機器上。
    </para>

    <sect2 xml:id="hayes-unsupported">
      <title>使用 Stock Hayes Modem</title>

      <para>通用的 Hayes 撥號器<F7>已經被內建在
	<command>tip</command>。在 <filename>/etc/remote</filename> 使用 <literal>at=hayes</literal>。
	  </para>

      <para>目前 Hayes 驅動程式還不夠聰明來辨識一些新的 modem 訊息的進階功能，例如
	<literal>BUSY</literal>、<literal>NO DIALTONE</literal>或
	<literal>CONNECT 115200</literal>。可以用 <command>tip</command> 的 <command>ATX0&amp;W</command> 命令將這些訊息關閉。
	 </para>

      <para><command>tip</command> 的撥號等待時間是 60 秒，modem 應該使用少一點的時間，否則 <command>tip</command> 會認為有通訊上的問題，試試看 <command>ATS7=45&amp;W</command>。
	  </para>
    </sect2>

    <sect2 xml:id="direct-at">
      <title>使用 <literal>AT</literal> 命令</title>

      <indexterm>
	<primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>在 <filename>/etc/remote</filename> 建立 <quote>direct</quote> 項目。
	  例如：如果 modem 被掛載在第一個串列阜 <filename>/dev/cuau0</filename>，
	  加入下面這一行：
	  </para>

      <programlisting>cuau0:dv=/dev/cuau0:br#19200:pa=none</programlisting>

      <para>在 <literal>br</literal> 屬性上使用 modem 支援的最高 <acronym>bps</acronym> 速率。然後，輸入
	  <command>tip cuau0</command> 來連結 modem。
	  </para>

      <para>或者，用 <systemitem class="username">root</systemitem> 執行 <command>cu</command>，如下：
	  </para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> 是串列阜，例如
	<filename>/dev/cuau0</filename>。
	<replaceable>speed</replaceable> 是速度，例如
	<literal>57600</literal>。 當完成輸入 AT 命令，輸入 <command>~.</command> 來離開。
	 </para>
    </sect2>

    <sect2 xml:id="gt-failure">
      <title>The <literal>@</literal> Sign Does Not Work</title>

      <para>The <literal>@</literal> 在電話號碼中是用來告訴
	  <command>tip</command> 在 <filename>/etc/phones</filename> 找到電話號碼，但是，<literal>@</literal>
	  符號也是一種檔案中的特殊字元，例如 <filename>/etc/remote</filename>，所以它需要用反斜線來跳脫：
	  </para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 xml:id="dial-command-line">
      <title>從命令列撥號</title>

      <para>放一個 <quote>通用</quote> 項目在
	<filename>/etc/remote</filename>。  舉個例：</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>現在應該可以運作了：</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>對於偏好使用 <command>cu</command> 超過
	<command>tip</command>的使用者，可以使用通用的 <literal>cu</literal> 項目：
	  </para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>然後輸入：</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 xml:id="set-bps">
      <title>設定 <acronym>bps</acronym> 速率</title>

      <para>替 <literal>tip1200</literal> 或 <literal>cu1200</literal> 放一個項目，使用任何的 <acronym>bps</acronym> 速率對 <literal>br</literal> 都是適合的。
	  <command>tip</command> 認為預設好的預設值是 1200&nbsp;bps，這也是為什麼有 <literal>tip1200</literal> 項目的原因，雖然，不見得需要使用1200&nbsp;bps。
	  </para>
    </sect2>

    <sect2 xml:id="terminal-server">
      <title>Accessing a Number of Hosts Through a Terminal
	Server</title>

      <para>無需每一次都要等到連上才能輸入 <command>CONNECT <replaceable>host</replaceable></command>，
	  可透過 <command>tip</command>'s <literal>cm</literal> 功能，
	舉個例，這些在 <filename>/etc/remote</filename> 
	的項目讓你輸入 <command>tip pain</command> 或者 <command>tip muffin</command> 來連接主機 <systemitem>pain</systemitem> 或者 <systemitem>muffin</systemitem>,
	和輸入 <command>tip deep13</command> 連接終端伺服器。</para>
      </para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

    </sect2>

    <sect2 xml:id="tip-multiline">
      <title>Using More Than One Line with
	<command>tip</command></title>

      <para>這是一個常見問題，當一個大學有好幾個 modem 線路，同時數千個學生正在嘗試使用他們。
	  </para>

      <para>建立一個項目在 <filename>/etc/remote</filename>，在 <literal>pn</literal> 功能上使用 <literal>@</literal>：
	  </para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>然後，列出在 <filename>/etc/phones</filename> 的電話號碼：</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> 將按照順序嘗試每一個上列的電話號碼，然後放棄。為了繼續重複嘗試，執行
	  可以用 <literal>while</literal> 迴圈執行 <command>tip</command>。
	  </para>
    </sect2>

    <sect2 xml:id="multi-controlp">
      <title>Using the Force Character</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo> 預設是 <quote>force</quote> 字元，用來告訴 <command>tip</command> 下一個字元是 literal data。
	used to tell <command>tip</command> that the next character is
	literal data.  The force character can be set to any other
	character with the <command>~s</command> escape, which means
	<quote>set a variable.</quote></para>

      <para>Type
	<command>~sforce=<replaceable>single-char</replaceable></command>
	followed by a newline.  <replaceable>single-char</replaceable>
	is any single character.  If
	<replaceable>single-char</replaceable> is left out, then the
	force character is the null character, which is accessed by
	typing
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	or <keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Space</keycap>
	</keycombo>.  A pretty good value for
	<replaceable>single-char</replaceable> is
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, which is only used on some terminal
	servers.</para>

      <para>To change the force character, specify the following in
	<filename>~/.tiprc</filename>:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 xml:id="uppercase">
      <title>Upper Case Characters</title>

      <para>This happens when
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo> is pressed, which is <command>tip</command>'s
	<quote>raise character</quote>, specially designed for people
	with broken caps-lock keys.  Use <command>~s</command> to set
	<literal>raisechar</literal> to something reasonable.  It can
	be set to be the same as the force character, if neither
	feature is used.</para>

      <para>Here is a sample <filename>~/.tiprc</filename> for
	<application>Emacs</application> users who need to type
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>2</keycap>
	</keycombo> and <keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>:</para>

    <programlisting>force=^^
raisechar=^^</programlisting>

      <para>The <literal>^^</literal> is
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	  </keycombo>.</para>

    </sect2>

    <sect2 xml:id="tip-filetransfer">
      <title>用<command>tip</command>傳檔案</title>

      <para>當與其他 &unix;-like 作業系統通訊時，可以用 <command>~p</command> (put) 和 <command>~t</command> (take) 來傳送和接收檔案，
	這些指令執行在遠端系統上執行 <command>cat</command> and <command>echo</command> 來接受和傳送檔案。語法如下：
	  </para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>因為沒有錯誤檢查機制，或許應該使用其他協定例如 zmodem。
	  </para>
    </sect2>

    <sect2 xml:id="zmodem-tip">
      <title>如何使用 <command>tip</command> tip 執行 <application>zmodem</application>？
	　</title>

      <para>為了收到檔案，在遠端執行一個傳送程式。然後在本機端輸入 <command>~C rz</command> 來接收他們。
	  </para>

      <para>至於傳送檔案，在遠端開啟接收程式，然後輸入 <command>~C sz<replaceable>files</replaceable></command>
	  來傳送檔案到遠端系統。
	  </para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info>
    <title>設定串列終端</title>

      <authorgroup>
	<author>
	<personname>
	  <firstname>Kazutaka</firstname>
	  <surname>YOKOTA</surname>
	  </personname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	<personname>
	  <firstname>Bill</firstname>
	  <surname>Paul</surname>
	  </personname>
	  <contrib>Based on a document by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>serial console</primary></indexterm>

    <para>&os; 有能力用串列阜上的 dumb 終端來開機，這個方法對想要安裝 &os; 卻沒有鍵盤和螢幕的系統管理員，還有想要偵錯核或驅動程式的開發者非常有用。
    </para>

    <para>如同 <xref linkend="boot"/> 所述，&os; 利用三階段 bootstrap，
	前兩階段的程式是在是在開機硬碟最前面的 slice 中的前幾區塊。
	這個開機區塊將第三階段的開機程式載入並執行。
    </para>

    <para>為了設定從串列終端開機，開機區塊程式、開機載入程式和核心皆需要設定。
    </para>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>快速串列終端設定</title>
      <para>
	  本節提供一個串列終端的快速概要。這步驟可以用在當 dumb 終端連接到 <filename>COM1</filename> 時。
	  </para>
      <procedure>
	<title>在 COM1 設定串列控制台
	  <filename>COM1</filename></title>

	<step>
	  <para>接上串列纜線到
	    <filename>COM1</filename>來控制終端。
	  </para>
	</step>

	<step>
	  <para>設定在串列控制台上顯示開機訊息，使用超級使用者來執行下列指令：
	  </para>

	  <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
	</step>

	<step>
	  <para>編輯 <filename>/etc/ttys</filename>，將 <filename>ttyu0</filename> 項目中的
	    <literal>off</literal> 改成 <literal>on</literal>，
	    <literal>dialup</literal> 改成 <literal>vt100</literal>
	    。否則，從串列控制台將不會要求輸入密碼，反而造成潛在的安全漏洞。
	  </para>
	</step>

	<step>
	  <para>重新啟動系統來看是否設定生效
	  </para>
	</step>

      </procedure>

      <para>如果需要不同的設定，下一節將有更入的設定說明
	  </para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>深入的串列控制台設定</title>

      <para>這節提供關於在 &os; 設定串列 console 比較細部的解釋。
	  </para>

      <procedure>
	<title>設定串列控制台</title>

	<step>
	  <para>準備一條串列纜線</para>

	  <indexterm><primary>null-modem cable</primary></indexterm>

	  <para>Use either a null-modem cable or a standard serial
	    cable and a null-modem adapter.  See <xref
	      linkend="term-cables-null"/> for a discussion on serial
	    cables.</para>
	</step>

	<step>
	  <para>Unplug the keyboard.</para>

	  <para>很多系統會在開機中的 Power-On Self-Test (<acronym>POST</acronym>)
	  偵測鍵盤，如果沒有偵測到鍵盤，則會發出錯誤訊息。一些機器會拒絕開機，除非接上鍵盤。
	  </para>

	  <para>如果電腦抱怨有這些錯誤，但是繼續開機，則不需要進一步設定。
	  </para>

	  <para>如果電腦因為沒有鍵盤而拒絕開機，設定 <acronym>BIOS</acronym> 來忽略這個錯誤。參考主機板手冊以了解如何進行的細節
	  </para>

	  <tip>
	    <para>試試看在 <acronym>BIOS</acronym> 設定鍵盤為 <quote>Not
		installed</quote>，這個設定告訴 <acronym>BIOS</acronym>　不要開機偵測鍵盤，所以系統不應該抱怨鍵盤不存在。
		如果這個選項不在 <acronym>BIOS</acronym> 中，改找 <quote>Halt on Error</quote> 看看，定這個選項為
		<quote>All but Keyboard</quote> 或者　<quote>No Errors</quote> 將會有同樣的效果。
		</para>
	  </tip>

	  <para>如系統有 &ps2; 滑鼠，拔掉它，
	    &ps2; 滑鼠與鍵盤共享一些硬體，插上滑鼠可以騙過鍵盤偵測，讓它以為鍵盤仍然存在。
	  </para>

	  <note>
	    <para>雖然大部分的系統可以在沒有鍵盤下開機，有一小部份不能在沒有 graphics adapter 下開機。
		 　一些系統可以藉由在 <acronym>BIOS</acronym> 設定 <quote>graphics adapter</quote> 成 <quote>Not installed</quote>，
		 在沒有顯示卡情況下開機。而不支援的這個選項的系統，如果在沒有顯示硬體情況下，將拒絕開機。
		對於這些機器，可以將顯示卡插著，雖然它只是一個沒用的板子。螢幕則不需要接上。
	    </para>
	  </note>
	</step>

	<step>
	  <para>插上 dumb 終端， an old computer with a modem
	    program, or the serial port on another &unix; box into the
	    serial port.</para>
	</step>

	<step>
	  <para>替串列阜新增適當的 <literal>hint.sio.*</literal>
	    項目到 <filename>/boot/device.hints</filename>。一些多阜卡需要核心設定選項支援。為了串列阜支援，參考 &man.sio.4; 相應的選項和 device hints。
	  </para>
	</step>

	<step>
	  <para>在開機硬碟分割區 <literal>a</literal> 的根目錄建立 <filename>boot.config</filename> 
	  </para>

	  <para>這個檔案指示開機區塊程式如何開啟系統，為了啟用串列 console，一個或多個下列選項是必要的。當使用多個選項，將他們全部放在同一行This file instructs the boot block code how to boot
	  </para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>
		切換內部或串列控制台。這個參數可用來切換控制台裝置。舉個例，為了從內部（video）控制台開機，
		Toggles between the internal and serial
		  consoles.  Use this to switch console devices.  For
		  instance, to boot from the internal (video) console,
		  use <option>-h</option> to direct the boot loader
		  and the kernel to use the serial port as its console
		  device.  Alternatively, to boot from the serial
		  port, use <option>-h</option> to tell the boot
		  loader and the kernel to use the video display as
		  the console instead.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>切換單一或雙控制台設定。Toggles between the single and dual console
		  configurations.  In the single configuration, the
		  console will be either the internal console (video
		  display) or the serial port, depending on the state
		  of <option>-h</option>.  In the dual console
		  configuration, both the video display  and the
		  serial port will become the console at the same
		  time, regardless of the state of
		  <option>-h</option>.  However, the dual console
		  configuration takes effect only while the boot
		  block is running.  Once the boot loader gets
		  control, the console specified by
		  <option>-h</option> becomes the only
		  console.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Makes the boot block probe the keyboard.  If no
		  keyboard is found, the <option>-D</option> and
		  <option>-h</option> options are automatically
		  set.</para>

		<note>
		  <para>Due to space constraints in the current
		    version of the boot blocks, <option>-P</option> is
		    capable of detecting extended keyboards only.
		    Keyboards with less than 101 keys and without F11
		    and F12 keys may not be detected.  Keyboards on
		    some laptops may not be properly found because of
		    this limitation.  If this is the case, do not use
		    <option>-P</option>.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Use either <option>-P</option> to select the console
	    automatically or <option>-h</option> to activate the
	    serial console.  Refer to &man.boot.8; and
	    &man.boot.config.5; for more details.</para>

	  <para>The options, except for <option>-P</option>, are
	    passed to the boot loader.  The boot loader will
	    determine whether the internal video or the serial port
	    should become the console by examining the state of
	    <option>-h</option>.  This means that if
	    <option>-D</option> is specified but <option>-h</option>
	    is not specified in <filename>/boot.config</filename>, the
	    serial port can be used as the console only during the
	    boot block as the boot loader will use the internal video
	    display as the console.</para>
	</step>

	<step>
	  <para>Boot the machine.</para>

	  <para>當 &os; 開始開機，開機區塊將 <filename>/boot.config</filename> 內容顯示在控制台上。
	  例如：
	  </para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>第二行只有在 <filename>/boot.config</filename> 設定 <option>-P</option> 下才會出現，表示鍵盤存在或不存在，
	  這些顯示在串列或內部控制，或兩個都顯示，全根據 <filename>/boot.config</filename> 中的選項：
	  </para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Options</entry>
		  <entry align="left">Message goes to</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>none</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>serial console</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard present</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard absent</entry>
		  <entry>serial console</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>After the message, there will be a small pause before
	    the boot blocks continue loading the boot loader and
	    before any further messages are printed to the console.
	    Under normal circumstances, there is no need to interrupt
	    the boot blocks, but one can do so in order to make sure
	    things are set up correctly.</para>

	  <para>Press any key, other than <keycap>Enter</keycap>, at
	    the console to interrupt the boot process.  The boot
	    blocks will then prompt for further action:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Verify that the above message appears on either the
	    serial or internal console, or both, according to the
	    options in <filename>/boot.config</filename>.  If the
	    message appears in the correct console, press
	    <keycap>Enter</keycap> to continue the boot
	    process.</para>

	  <para>If there is no prompt on the serial terminal,
	    something is wrong with the settings.  Enter
	    <option>-h</option> then <keycap>Enter</keycap> or
	    <keycap>Return</keycap> to tell the boot block (and then
	    the boot loader and the kernel) to choose the serial port
	    for the console.  Once the system is up, go back and check
	    what went wrong.</para>
	</step>
      </procedure>

      <para>During the third stage of the boot process, one can still
	switch between the internal console and the serial console by
	setting appropriate environment variables in the boot loader.
	See &man.loader.8; for more
	information.</para>

      <note>
	<para>This line in <filename>/boot/loader.conf</filename> or
	  <filename>/boot/loader.conf.local</filename> configures the
	  boot loader and the kernel to send their boot messages to
	  the serial console, regardless of the options in
	  <filename>/boot.config</filename>:</para>

	<programlisting>console="comconsole"</programlisting>

	<para>That line should be the first line of
	  <filename>/boot/loader.conf</filename> so that boot messages
	  are displayed on the serial console as early as
	  possible.</para>

	<para>If that line does not exist, or if it is set to
	  <literal>console="vidconsole"</literal>, the boot loader and
	  the kernel will use whichever console is indicated by
	  <option>-h</option> in the boot block.  See
	  &man.loader.conf.5; for more information.</para>

	<para>At the moment, the boot loader has no option
	  equivalent to <option>-P</option> in the boot block, and
	  there is no provision to automatically select the internal
	  console and the serial console based on the presence of the
	  keyboard.</para>
      </note>

      <tip>
	<para>While it is not required, it is possible to provide a
	  <command>login</command> prompt over the serial line.  To
	  configure this, edit the entry for the serial port in
	  <filename>/etc/ttys</filename> using the instructions in
	  <xref linkend="term-config"/>.  If the speed of the serial
	  port has been changed, change <literal>std.9600</literal> to
	  match the new setting.</para>
      </tip>
    </sect2>

    <sect2>
      <title>設定較快的序列阜速度</title>

      <para>預設下，序列阜速度是 9600 baud， 8
	bits, no parity, and 1 stop bit.  為了改變預設的 console 速度，使用下面其中一個選項:</para>

      <itemizedlist>
	<listitem>
	  <para>編輯 <filename>/etc/make.conf</filename> 並解設定
	    <varname>BOOT_COMCONSOLE_SPEED</varname> ，指定新的終端速度。
		然後，編譯並且安裝開機區塊和開機載入器：
	    </para>

	  <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>

	  <para>If the serial console is configured in some other way
	    than by booting with <option>-h</option>, or if the serial
	    console used by the kernel is different from the one used
	    by the boot blocks, add the following option, with the
	    desired speed, to a custom kernel configuration file and
	    compile a new kernel:</para>

	  <programlisting>options CONSPEED=<replaceable>19200</replaceable></programlisting>
	</listitem>

	<listitem>
	  <para>Add the <option>-S
	      <replaceable>19200</replaceable></option> boot option to
	    <filename>/boot.config</filename>, replacing
	    <replaceable>19200</replaceable> with the speed to
	    use.</para>
	</listitem>

	<listitem>
	  <para>加入下列選項到
	    <filename>/boot/loader.conf</filename>.  Replace
	    <replaceable>115200</replaceable> with the speed to
	    use.</para>

	  <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="<replaceable>115200</replaceable>"
console="comconsole,vidconsole"</programlisting>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="serialconsole-ddb">
      <title>Entering the DDB Debugger from the Serial Line</title>

      <para>為了設定核心支援從序列 console 跳入核心偵錯器的能力，在客製化核心設定檔加入下列選項並且利用
	  在 <xref linkend="kernelconfig"/> 的指令編譯核心。注意，當這是一個對於遠端偵測的有用工具時，假如有人偽造假的 BREAK 並送到序列阜，
	  它將變的很危險。想要知道更多關於核心偵錯器請參考 &man.ddb.4; and &man.ddb.8;。
	</para>

      <programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
    </sect2>
  </sect1>
</chapter>
